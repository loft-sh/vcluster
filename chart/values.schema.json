{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://vcluster.com/schemas/config",
  "$defs": {
    "BackingStore": {
      "properties": {
        "etcd": {
          "$ref": "#/$defs/Etcd",
          "description": "Etcd defines that etcd should be used as the backend for the virtual cluster"
        },
        "database": {
          "$ref": "#/$defs/Database",
          "description": "Database defines that a database backend should be used as the backend for the virtual cluster. This uses a project called kine under the hood which is a shim for bridging Kubernetes and relational databases."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CentralAdmission": {
      "properties": {
        "validatingWebhooks": {
          "items": {
            "$ref": "#/$defs/ValidatingWebhookConfiguration"
          },
          "type": "array",
          "description": "ValidatingWebhooks are validating webhooks that should be enforced in the virtual cluster"
        },
        "mutatingWebhooks": {
          "items": {
            "$ref": "#/$defs/MutatingWebhookConfiguration"
          },
          "type": "array",
          "description": "MutatingWebhooks are mutating webhooks that should be enforced in the virtual cluster"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ControlPlane": {
      "properties": {
        "distro": {
          "$ref": "#/$defs/Distro",
          "description": "Distro holds virtual cluster related distro options. A distro cannot be changed after vCluster is deployed."
        },
        "backingStore": {
          "$ref": "#/$defs/BackingStore",
          "description": "BackingStore defines which backing store to use for virtual cluster. If not defined will use embedded database as a default backing store."
        },
        "coredns": {
          "$ref": "#/$defs/CoreDNS",
          "description": "CoreDNS defines everything related to the coredns that is deployed and used within the vCluster."
        },
        "proxy": {
          "$ref": "#/$defs/ControlPlaneProxy",
          "description": "Proxy defines options for the virtual cluster control plane proxy that is used to do authentication and intercept requests."
        },
        "hostPathMapper": {
          "$ref": "#/$defs/HostPathMapper",
          "description": "HostPathMapper defines if vCluster should rewrite host paths.",
          "pro": true
        },
        "ingress": {
          "$ref": "#/$defs/ControlPlaneIngress",
          "description": "Ingress defines options for vCluster ingress deployed by Helm."
        },
        "service": {
          "$ref": "#/$defs/ControlPlaneService",
          "description": "Service defines options for vCluster service deployed by Helm."
        },
        "statefulSet": {
          "$ref": "#/$defs/ControlPlaneStatefulSet",
          "description": "StatefulSet defines options for vCluster statefulSet deployed by Helm."
        },
        "serviceMonitor": {
          "$ref": "#/$defs/ServiceMonitor",
          "description": "ServiceMonitor can be used to automatically create a service monitor for vCluster deployment itself."
        },
        "advanced": {
          "$ref": "#/$defs/ControlPlaneAdvanced",
          "description": "Advanced holds additional configuration for the vCluster control plane."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ControlPlaneAdvanced": {
      "properties": {
        "defaultImageRegistry": {
          "type": "string",
          "description": "DefaultImageRegistry will be used as a prefix for all internal images deployed by vCluster or Helm. This makes it easy to\nupload all required vCluster images to a single private repository and set this value. Workload images are not affected by this."
        },
        "virtualScheduler": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "VirtualScheduler defines if a scheduler should be used within the virtual cluster or the scheduling decision for workloads will be made by the host cluster."
        },
        "serviceAccount": {
          "$ref": "#/$defs/ControlPlaneServiceAccount",
          "description": "ServiceAccount specifies options for the vCluster control plane service account."
        },
        "workloadServiceAccount": {
          "$ref": "#/$defs/ControlPlaneWorkloadServiceAccount",
          "description": "WorkloadServiceAccount specifies options for the service account that will be used for the workloads that run within the virtual cluster."
        },
        "headlessService": {
          "$ref": "#/$defs/ControlPlaneHeadlessService",
          "description": "HeadlessService specifies options for the headless service used for the vCluster StatefulSet."
        },
        "globalMetadata": {
          "$ref": "#/$defs/ControlPlaneGlobalMetadata",
          "description": "GlobalMetadata is metadata that will be added to all resources deployed by Helm."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ControlPlaneGlobalMetadata": {
      "properties": {
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for this resource."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ControlPlaneHeadlessService": {
      "properties": {
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for this resource."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Labels are extra labels for this resource."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ControlPlaneHighAvailability": {
      "properties": {
        "replicas": {
          "type": "integer",
          "description": "Replicas is the amount of replicas to use for the statefulSet."
        },
        "leaseDuration": {
          "type": "integer",
          "description": "LeaseDuration is the time to lease for the leader."
        },
        "renewDeadline": {
          "type": "integer",
          "description": "RenewDeadline is the deadline to renew a lease for the leader."
        },
        "retryPeriod": {
          "type": "integer",
          "description": "RetryPeriod is the time until a replica will retry to get a lease."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ControlPlaneIngress": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines if the control plane ingress should be enabled"
        },
        "host": {
          "type": "string",
          "description": "Host is the host where vCluster will be reachable"
        },
        "pathType": {
          "type": "string",
          "description": "PathType is the path type of the ingress"
        },
        "spec": {
          "type": "object",
          "description": "Spec allows you to configure extra ingress options."
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for this resource."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Labels are extra labels for this resource."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ControlPlanePersistence": {
      "properties": {
        "volumeClaim": {
          "$ref": "#/$defs/VolumeClaim",
          "description": "VolumeClaim can be used to configure the persistent volume claim."
        },
        "volumeClaimTemplates": {
          "items": {
            "type": "object"
          },
          "type": "array",
          "description": "VolumeClaimTemplates defines the volumeClaimTemplates for the statefulSet"
        },
        "addVolumes": {
          "items": {
            "type": "object"
          },
          "type": "array",
          "description": "AddVolumes defines extra volumes for the pod"
        },
        "addVolumeMounts": {
          "items": {
            "$ref": "#/$defs/VolumeMount"
          },
          "type": "array",
          "description": "AddVolumeMounts defines extra volume mounts for the container"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ControlPlaneProbes": {
      "properties": {
        "livenessProbe": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "LivenessProbe specifies if the liveness probe for the container should be enabled"
        },
        "readinessProbe": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "ReadinessProbe specifies if the readiness probe for the container should be enabled"
        },
        "startupProbe": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "StartupProbe specifies if the startup probe for the container should be enabled"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ControlPlaneProxy": {
      "properties": {
        "bindAddress": {
          "type": "string",
          "description": "BindAddress under which vCluster will expose the proxy."
        },
        "port": {
          "type": "integer",
          "description": "Port under which vCluster will expose the proxy. Changing port is currently not supported."
        },
        "extraSANs": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "ExtraSANs are extra hostnames to sign the vCluster proxy certificate for."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ControlPlaneScheduling": {
      "properties": {
        "nodeSelector": {
          "type": "object",
          "description": "NodeSelector is the node selector to apply to the pod."
        },
        "affinity": {
          "type": "object",
          "description": "Affinity is the affinity to apply to the pod."
        },
        "tolerations": {
          "items": {
            "type": "object"
          },
          "type": "array",
          "description": "Tolerations are the tolerations to apply to the pod."
        },
        "priorityClassName": {
          "type": "string",
          "description": "PriorityClassName is the priority class name for the the pod."
        },
        "podManagementPolicy": {
          "type": "string",
          "description": "PodManagementPolicy is the statefulSet pod management policy."
        },
        "topologySpreadConstraints": {
          "items": true,
          "type": "array",
          "description": "TopologySpreadConstraints are the topology spread constraints for the pod."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ControlPlaneSecurity": {
      "properties": {
        "podSecurityContext": {
          "type": "object",
          "description": "PodSecurityContext specifies security context options on the pod level."
        },
        "containerSecurityContext": {
          "type": "object",
          "description": "ContainerSecurityContext specifies security context options on the container level."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ControlPlaneService": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines if the control plane service should be enabled"
        },
        "spec": {
          "type": "object",
          "description": "Spec allows you to configure extra service options."
        },
        "kubeletNodePort": {
          "type": "integer",
          "description": "KubeletNodePort is the node port where the fake kubelet is exposed. Defaults to 0."
        },
        "httpsNodePort": {
          "type": "integer",
          "description": "HTTPSNodePort is the node port where https is exposed. Defaults to 0."
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for this resource."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Labels are extra labels for this resource."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ControlPlaneServiceAccount": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled specifies if the service account should get deployed."
        },
        "name": {
          "type": "string",
          "description": "Name specifies what name to use for the service account."
        },
        "imagePullSecrets": {
          "items": {
            "$ref": "#/$defs/ImagePullSecretName"
          },
          "type": "array",
          "description": "ImagePullSecrets defines extra image pull secrets for the service account."
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for this resource."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Labels are extra labels for this resource."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ControlPlaneStatefulSet": {
      "properties": {
        "highAvailability": {
          "$ref": "#/$defs/ControlPlaneHighAvailability",
          "description": "HighAvailability holds options related to high availability."
        },
        "resources": {
          "$ref": "#/$defs/Resources",
          "description": "Resources are the resource requests and limits for the statefulSet container."
        },
        "scheduling": {
          "$ref": "#/$defs/ControlPlaneScheduling",
          "description": "Scheduling holds options related to scheduling."
        },
        "security": {
          "$ref": "#/$defs/ControlPlaneSecurity",
          "description": "Security defines pod or container security context."
        },
        "probes": {
          "$ref": "#/$defs/ControlPlaneProbes",
          "description": "Probes enables or disables the main container probes."
        },
        "persistence": {
          "$ref": "#/$defs/ControlPlanePersistence",
          "description": "Persistence defines options around persistence for the statefulSet."
        },
        "enableServiceLinks": {
          "type": "boolean",
          "description": "EnableServiceLinks for the StatefulSet pod"
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for this resource."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Labels are extra labels for this resource."
        },
        "pods": {
          "$ref": "#/$defs/LabelsAndAnnotations",
          "description": "Additional labels or annotations for the statefulSet pods."
        },
        "image": {
          "$ref": "#/$defs/StatefulSetImage",
          "description": "Image is the image for the controlPlane statefulSet container"
        },
        "imagePullPolicy": {
          "type": "string",
          "description": "ImagePullPolicy is the policy how to pull the image."
        },
        "workingDir": {
          "type": "string",
          "description": "WorkingDir specifies in what folder the main process should get started."
        },
        "command": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Command allows you to override the main command."
        },
        "args": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Args allows you to override the main arguments."
        },
        "env": {
          "items": {
            "type": "object"
          },
          "type": "array",
          "description": "Env are additional environment variables for the statefulSet container."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ControlPlaneWorkloadServiceAccount": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled specifies if the service account for the workloads should get deployed."
        },
        "name": {
          "type": "string",
          "description": "Name specifies what name to use for the service account for the virtual cluster workloads."
        },
        "imagePullSecrets": {
          "items": {
            "$ref": "#/$defs/ImagePullSecretName"
          },
          "type": "array",
          "description": "ImagePullSecrets defines extra image pull secrets for the workload service account."
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for this resource."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Labels are extra labels for this resource."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CoreDNS": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines if coredns is enabled"
        },
        "embedded": {
          "type": "boolean",
          "description": "Embedded defines if vCluster will start the embedded coredns service within the control-plane and not as a separate deployment. This is a PRO feature.",
          "pro": true
        },
        "service": {
          "$ref": "#/$defs/CoreDNSService",
          "description": "Service holds extra options for the coredns service deployed within the virtual cluster"
        },
        "deployment": {
          "$ref": "#/$defs/CoreDNSDeployment",
          "description": "Deployment holds extra options for the coredns deployment deployed within the virtual cluster"
        },
        "overwriteConfig": {
          "type": "string",
          "description": "OverwriteConfig can be used to overwrite the coredns config"
        },
        "overwriteManifests": {
          "type": "string",
          "description": "OverwriteManifests can be used to overwrite the coredns manifests used to deploy coredns"
        },
        "priorityClassName": {
          "type": "string",
          "description": "PriorityClassName specifies the priority class name for the CoreDNS pods."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CoreDNSDeployment": {
      "properties": {
        "image": {
          "type": "string",
          "description": "Image is the coredns image to use"
        },
        "replicas": {
          "type": "integer",
          "description": "Replicas is the amount of coredns pods to run."
        },
        "nodeSelector": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "NodeSelector is the node selector to use for coredns."
        },
        "resources": {
          "$ref": "#/$defs/Resources",
          "description": "Resources are the desired resources for coredns."
        },
        "pods": {
          "$ref": "#/$defs/LabelsAndAnnotations",
          "description": "Pods is additional metadata for the coredns pods."
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for this resource."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Labels are extra labels for this resource."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CoreDNSService": {
      "properties": {
        "spec": {
          "type": "object",
          "description": "Spec holds extra options for the coredns service"
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for this resource."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Labels are extra labels for this resource."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Database": {
      "properties": {
        "embedded": {
          "$ref": "#/$defs/DatabaseKine",
          "description": "Embedded defines that an embedded database (sqlite) should be used as the backend for the virtual cluster"
        },
        "external": {
          "$ref": "#/$defs/DatabaseKine",
          "description": "External defines that an external database should be used as the backend for the virtual cluster"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "DatabaseKine": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines if the database should be used."
        },
        "dataSource": {
          "type": "string",
          "description": "DataSource is the kine dataSource to use for the database. This depends on the database format.\nThis is optional for the embedded database. Examples:\n* mysql: mysql://username:password@tcp(hostname:3306)/k3s\n* postgres: postgres://username:password@hostname:5432/k3s"
        },
        "keyFile": {
          "type": "string",
          "description": "KeyFile is the key file to use for the database. This is optional."
        },
        "certFile": {
          "type": "string",
          "description": "CertFile is the cert file to use for the database. This is optional."
        },
        "caFile": {
          "type": "string",
          "description": "CaFile is the ca file to use for the database. This is optional."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "DenyRule": {
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the check."
        },
        "namespaces": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Namespace describe a list of namespaces that will be affected by the check.\nAn empty list means that all namespaces will be affected.\nIn case of ClusterScoped rules, only the Namespace resource is affected."
        },
        "rules": {
          "items": {
            "$ref": "#/$defs/RuleWithVerbs"
          },
          "type": "array",
          "description": "Rules describes on which verbs and on what resources/subresources the webhook is enforced.\nThe webhook is enforced if it matches any Rule.\nThe version of the request must match the rule version exactly. Equivalent matching is not supported."
        },
        "excludedUsers": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "ExcludedUsers describe a list of users for which the checks will be skipped.\nImpersonation attempts on these users will still be subjected to the checks."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Distro": {
      "properties": {
        "k8s": {
          "$ref": "#/$defs/DistroK8s",
          "description": "K8S holds K8s relevant configuration."
        },
        "k3s": {
          "$ref": "#/$defs/DistroK3s",
          "description": "K3S holds K3s relevant configuration."
        },
        "k0s": {
          "$ref": "#/$defs/DistroK0s",
          "description": "K0S holds k0s relevant configuration."
        },
        "eks": {
          "$ref": "#/$defs/DistroK8s",
          "description": "EKS holds eks relevant configuration."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "DistroContainer": {
      "properties": {
        "image": {
          "$ref": "#/$defs/Image",
          "description": "Image is the distro image"
        },
        "imagePullPolicy": {
          "type": "string",
          "description": "ImagePullPolicy is the pull policy for the distro image"
        },
        "command": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Command is the command to start the distro binary. This will override the existing command."
        },
        "extraArgs": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "ExtraArgs are additional arguments to pass to the distro binary."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "DistroContainerEnabled": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled signals this container should be enabled."
        },
        "image": {
          "$ref": "#/$defs/Image",
          "description": "Image is the distro image"
        },
        "imagePullPolicy": {
          "type": "string",
          "description": "ImagePullPolicy is the pull policy for the distro image"
        },
        "command": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Command is the command to start the distro binary. This will override the existing command."
        },
        "extraArgs": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "ExtraArgs are additional arguments to pass to the distro binary."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "DistroK0s": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled specifies if the k0s distro should be enabled. Only one distro can be enabled at the same time."
        },
        "config": {
          "type": "string",
          "description": "Config allows you to override the k0s config passed to the k0s binary."
        },
        "env": {
          "items": {
            "type": "object"
          },
          "type": "array",
          "description": "Env are extra environment variables to use for the main container and NOT the init container."
        },
        "resources": {
          "type": "object",
          "description": "Resources for the distro init container"
        },
        "securityContext": {
          "type": "object",
          "description": "Security options can be used for the distro init container"
        },
        "image": {
          "$ref": "#/$defs/Image",
          "description": "Image is the distro image"
        },
        "imagePullPolicy": {
          "type": "string",
          "description": "ImagePullPolicy is the pull policy for the distro image"
        },
        "command": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Command is the command to start the distro binary. This will override the existing command."
        },
        "extraArgs": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "ExtraArgs are additional arguments to pass to the distro binary."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "DistroK3s": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled specifies if the K3s distro should be enabled. Only one distro can be enabled at the same time."
        },
        "token": {
          "type": "string",
          "description": "Token is the K3s token to use. If empty, vCluster will choose one."
        },
        "env": {
          "items": {
            "type": "object"
          },
          "type": "array",
          "description": "Env are extra environment variables to use for the main container and NOT the init container."
        },
        "resources": {
          "type": "object",
          "description": "Resources for the distro init container"
        },
        "securityContext": {
          "type": "object",
          "description": "Security options can be used for the distro init container"
        },
        "image": {
          "$ref": "#/$defs/Image",
          "description": "Image is the distro image"
        },
        "imagePullPolicy": {
          "type": "string",
          "description": "ImagePullPolicy is the pull policy for the distro image"
        },
        "command": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Command is the command to start the distro binary. This will override the existing command."
        },
        "extraArgs": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "ExtraArgs are additional arguments to pass to the distro binary."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "DistroK8s": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled specifies if the K8s distro should be enabled. Only one distro can be enabled at the same time."
        },
        "apiServer": {
          "$ref": "#/$defs/DistroContainerEnabled",
          "description": "APIServer holds configuration specific to starting the api server."
        },
        "controllerManager": {
          "$ref": "#/$defs/DistroContainerEnabled",
          "description": "ControllerManager holds configuration specific to starting the controller manager."
        },
        "scheduler": {
          "$ref": "#/$defs/DistroContainer",
          "description": "Scheduler holds configuration specific to starting the scheduler. Enable this via controlPlane.advanced.virtualScheduler.enabled"
        },
        "env": {
          "items": {
            "type": "object"
          },
          "type": "array",
          "description": "Env are extra environment variables to use for the main container and NOT the init container."
        },
        "resources": {
          "type": "object",
          "description": "Resources for the distro init container"
        },
        "securityContext": {
          "type": "object",
          "description": "Security options can be used for the distro init container"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "EnableAutoSwitch": {
      "properties": {
        "enabled": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "boolean"
            }
          ],
          "description": "Enabled defines if this option should be enabled."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "EnableSwitch": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines if this option should be enabled."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Etcd": {
      "properties": {
        "embedded": {
          "$ref": "#/$defs/EtcdEmbedded",
          "description": "Embedded defines to use embedded etcd as a storage backend for the virtual cluster",
          "pro": true
        },
        "deploy": {
          "$ref": "#/$defs/EtcdDeploy",
          "description": "Deploy defines to use an external etcd that is deployed by the helm chart"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "EtcdDeploy": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines that an external etcd should be deployed."
        },
        "statefulSet": {
          "$ref": "#/$defs/EtcdDeployStatefulSet",
          "description": "StatefulSet holds options for the external etcd statefulSet."
        },
        "service": {
          "$ref": "#/$defs/EtcdDeployService",
          "description": "Service holds options for the external etcd service."
        },
        "headlessService": {
          "$ref": "#/$defs/EtcdDeployHeadlessService",
          "description": "HeadlessService holds options for the external etcd headless service."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "EtcdDeployHeadlessService": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines if the etcd headless service should be deployed"
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for the external etcd headless service"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "EtcdDeployService": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines if the etcd service should be deployed"
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for the external etcd service"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "EtcdDeployStatefulSet": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines if the statefulSet should be deployed"
        },
        "enableServiceLinks": {
          "type": "boolean",
          "description": "EnableServiceLinks for the StatefulSet pod"
        },
        "image": {
          "$ref": "#/$defs/Image",
          "description": "Image is the image to use for the external etcd statefulSet"
        },
        "imagePullPolicy": {
          "type": "string",
          "description": "ImagePullPolicy is the pull policy for the external etcd image"
        },
        "env": {
          "items": {
            "type": "object"
          },
          "type": "array",
          "description": "Env are extra environment variables"
        },
        "extraArgs": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "ExtraArgs are appended to the etcd command."
        },
        "resources": {
          "$ref": "#/$defs/Resources",
          "description": "Resources the etcd can consume"
        },
        "pods": {
          "$ref": "#/$defs/LabelsAndAnnotations",
          "description": "Pods defines extra metadata for the etcd pods."
        },
        "highAvailability": {
          "$ref": "#/$defs/ExternalEtcdHighAvailability",
          "description": "HighAvailability are high availability options"
        },
        "scheduling": {
          "$ref": "#/$defs/ControlPlaneScheduling",
          "description": "Scheduling options for the etcd pods."
        },
        "security": {
          "$ref": "#/$defs/ControlPlaneSecurity",
          "description": "Security options for the etcd pods."
        },
        "persistence": {
          "$ref": "#/$defs/ExternalEtcdPersistence",
          "description": "Persistence options for the etcd pods."
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for this resource."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Labels are extra labels for this resource."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "EtcdEmbedded": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines if the embedded etcd should be used.",
          "pro": true
        },
        "migrateFromDeployedEtcd": {
          "type": "boolean",
          "description": "MigrateFromDeployedEtcd signals that vCluster should migrate from the deployed external etcd to embedded etcd."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Experimental": {
      "properties": {
        "deploy": {
          "$ref": "#/$defs/ExperimentalDeploy",
          "description": "Deploy allows you to configure manifests and Helm charts to deploy within the virtual cluster."
        },
        "syncSettings": {
          "$ref": "#/$defs/ExperimentalSyncSettings",
          "description": "SyncSettings are advanced settings for the syncer controller."
        },
        "genericSync": {
          "$ref": "#/$defs/ExperimentalGenericSync",
          "description": "GenericSync holds options to generically sync resources from virtual cluster to host."
        },
        "multiNamespaceMode": {
          "$ref": "#/$defs/ExperimentalMultiNamespaceMode",
          "description": "MultiNamespaceMode tells virtual cluster to sync to multiple namespaces instead of a single one. This will map each virtual cluster namespace to a single namespace in the host cluster."
        },
        "isolatedControlPlane": {
          "$ref": "#/$defs/ExperimentalIsolatedControlPlane",
          "description": "IsolatedControlPlane is a feature to run the vCluster control plane in a different Kubernetes cluster than the workloads themselves.",
          "pro": true
        },
        "virtualClusterKubeConfig": {
          "$ref": "#/$defs/VirtualClusterKubeConfig",
          "description": "VirtualClusterKubeConfig allows you to override distro specifics and specify where vCluster will find the required certificates and vCluster config."
        },
        "denyProxyRequests": {
          "items": {
            "$ref": "#/$defs/DenyRule"
          },
          "type": "array",
          "description": "DenyProxyRequests denies certain requests in the vCluster proxy.",
          "pro": true
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ExperimentalDeploy": {
      "properties": {
        "manifests": {
          "type": "string",
          "description": "Manifests are raw Kubernetes manifests that should get applied within the virtual cluster."
        },
        "manifestsTemplate": {
          "type": "string",
          "description": "ManifestsTemplate is a Kubernetes manifest template that will be rendered with vCluster values before applying it within the virtual cluster."
        },
        "helm": {
          "items": {
            "$ref": "#/$defs/ExperimentalDeployHelm"
          },
          "type": "array",
          "description": "Helm are Helm charts that should get deployed into the virtual cluster"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ExperimentalDeployHelm": {
      "properties": {
        "chart": {
          "$ref": "#/$defs/ExperimentalDeployHelmChart",
          "description": "Chart defines what chart should get deployed."
        },
        "release": {
          "$ref": "#/$defs/ExperimentalDeployHelmRelease",
          "description": "Release defines what release should get deployed."
        },
        "values": {
          "type": "string",
          "description": "Values defines what values should get used."
        },
        "timeout": {
          "type": "string",
          "description": "Timeout defines the timeout for Helm"
        },
        "bundle": {
          "type": "string",
          "description": "Bundle allows to compress the Helm chart and specify this instead of an online chart"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ExperimentalDeployHelmChart": {
      "properties": {
        "name": {
          "type": "string"
        },
        "repo": {
          "type": "string"
        },
        "insecure": {
          "type": "boolean"
        },
        "version": {
          "type": "string"
        },
        "username": {
          "type": "string"
        },
        "password": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ExperimentalDeployHelmRelease": {
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the release"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the release"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ExperimentalGenericSync": {
      "properties": {
        "version": {
          "type": "string",
          "description": "Version is the config version"
        },
        "export": {
          "items": {
            "$ref": "#/$defs/Export"
          },
          "type": "array",
          "description": "Exports syncs a resource from the virtual cluster to the host"
        },
        "import": {
          "items": {
            "$ref": "#/$defs/Import"
          },
          "type": "array",
          "description": "Imports syncs a resource from the host cluster to virtual cluster"
        },
        "hooks": {
          "$ref": "#/$defs/Hooks",
          "description": "Hooks are hooks that can be used to inject custom patches before syncing"
        },
        "clusterRole": {
          "$ref": "#/$defs/ExperimentalGenericSyncExtraRules"
        },
        "role": {
          "$ref": "#/$defs/ExperimentalGenericSyncExtraRules"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ExperimentalGenericSyncExtraRules": {
      "properties": {
        "extraRules": {
          "items": true,
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ExperimentalIsolatedControlPlane": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled specifies if the isolated control plane feature should be enabled."
        },
        "headless": {
          "type": "boolean",
          "description": "Headless states that Helm should deploy the vCluster in headless mode for the isolated control plane."
        },
        "kubeConfig": {
          "type": "string",
          "description": "KubeConfig is the path where to find the remote workload cluster kubeconfig."
        },
        "namespace": {
          "type": "string",
          "description": "Namespace is the namespace where to sync the workloads into."
        },
        "service": {
          "type": "string",
          "description": "Service is the vCluster service in the remote cluster."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ExperimentalMultiNamespaceMode": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled specifies if multi namespace mode should get enabled"
        },
        "namespaceLabels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "NamespaceLabels are extra labels that will be added by vCluster to each created namespace."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ExperimentalSyncSettings": {
      "properties": {
        "disableSync": {
          "type": "boolean",
          "description": "DisableSync will not sync any resources and disable most control plane functionality.",
          "pro": true
        },
        "rewriteKubernetesService": {
          "type": "boolean",
          "description": "RewriteKubernetesService will rewrite the Kubernetes service to point to the vCluster service if disableSync is enabled",
          "pro": true
        },
        "targetNamespace": {
          "type": "string",
          "description": "TargetNamespace is the namespace where the workloads should get synced to."
        },
        "setOwner": {
          "type": "boolean",
          "description": "SetOwner specifies if vCluster should set an owner reference on the synced objects to the vCluster service. This allows for easy garbage collection."
        },
        "syncLabels": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "SyncLabels are labels that should get not rewritten when syncing from the virtual cluster."
        },
        "hostMetricsBindAddress": {
          "type": "string",
          "description": "HostMetricsBindAddress is the bind address for the local manager"
        },
        "virtualMetricsBindAddress": {
          "type": "string",
          "description": "VirtualMetricsBindAddress is the bind address for the virtual manager"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Export": {
      "properties": {
        "apiVersion": {
          "type": "string",
          "description": "APIVersion of the object to sync"
        },
        "kind": {
          "type": "string",
          "description": "Kind of the object to sync"
        },
        "optional": {
          "type": "boolean"
        },
        "replaceOnConflict": {
          "type": "boolean",
          "description": "ReplaceWhenInvalid determines if the controller should try to recreate the object\nif there is a problem applying"
        },
        "patches": {
          "items": {
            "$ref": "#/$defs/Patch"
          },
          "type": "array",
          "description": "Patches are the patches to apply on the virtual cluster objects\nwhen syncing them from the host cluster"
        },
        "reversePatches": {
          "items": {
            "$ref": "#/$defs/Patch"
          },
          "type": "array",
          "description": "ReversePatches are the patches to apply to host cluster objects\nafter it has been synced to the virtual cluster"
        },
        "selector": {
          "$ref": "#/$defs/Selector",
          "description": "Selector is a label selector to select the synced objects in the virtual cluster.\nIf empty, all objects will be synced."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ExportKubeConfig": {
      "properties": {
        "context": {
          "type": "string",
          "description": "Context is the name of the context within the generated kubeconfig to use."
        },
        "server": {
          "type": "string",
          "description": "Override the default https://localhost:8443 and specify a custom hostname for the generated kubeconfig."
        },
        "secret": {
          "$ref": "#/$defs/ExportKubeConfigSecretReference",
          "description": "Declare in which host cluster secret vCluster should store the generated virtual cluster kubeconfig.\nIf this is not defined, vCluster create it with `vc-NAME`. If you specify another name,\nvCluster creates the config in this other secret."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "description": "ExportKubeConfig describes how vCluster should export the vCluster kubeconfig."
    },
    "ExportKubeConfigSecretReference": {
      "properties": {
        "name": {
          "type": "string",
          "description": "Name is the name of the secret where the kubeconfig should get stored."
        },
        "namespace": {
          "type": "string",
          "description": "Namespace where vCluster should store the kubeconfig secret. If this is not equal to the namespace\nwhere you deployed vCluster, you need to make sure vCluster has access to this other namespace."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "description": "Declare in which host cluster secret vCluster should store the generated virtual cluster kubeconfig."
    },
    "ExternalEtcdHighAvailability": {
      "properties": {
        "replicas": {
          "type": "integer",
          "description": "Replicas are the amount of pods to use."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ExternalEtcdPersistence": {
      "properties": {
        "volumeClaim": {
          "$ref": "#/$defs/ExternalEtcdPersistenceVolumeClaim",
          "description": "VolumeClaim can be used to configure the persistent volume claim."
        },
        "volumeClaimTemplates": {
          "items": {
            "type": "object"
          },
          "type": "array",
          "description": "VolumeClaimTemplates defines the volumeClaimTemplates for the statefulSet"
        },
        "addVolumes": {
          "items": {
            "type": "object"
          },
          "type": "array",
          "description": "AddVolumes defines extra volumes for the pod"
        },
        "addVolumeMounts": {
          "items": {
            "$ref": "#/$defs/VolumeMount"
          },
          "type": "array",
          "description": "AddVolumeMounts defines extra volume mounts for the container"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ExternalEtcdPersistenceVolumeClaim": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled enables deploying a persistent volume claim."
        },
        "accessModes": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "AccessModes are the persistent volume claim access modes."
        },
        "retentionPolicy": {
          "type": "string",
          "description": "RetentionPolicy is the persistent volume claim retention policy."
        },
        "size": {
          "type": "string",
          "description": "Size is the persistent volume claim storage size."
        },
        "storageClass": {
          "type": "string",
          "description": "StorageClass is the persistent volume claim storage class."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Hook": {
      "properties": {
        "apiVersion": {
          "type": "string",
          "description": "APIVersion of the object to sync"
        },
        "kind": {
          "type": "string",
          "description": "Kind of the object to sync"
        },
        "verbs": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Verbs are the verbs that the hook should mutate"
        },
        "patches": {
          "items": {
            "$ref": "#/$defs/Patch"
          },
          "type": "array",
          "description": "Patches are the patches to apply on the object to be synced"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Hooks": {
      "properties": {
        "hostToVirtual": {
          "items": {
            "$ref": "#/$defs/Hook"
          },
          "type": "array",
          "description": "HostToVirtual is a hook that is executed before syncing from the host to the virtual cluster"
        },
        "virtualToHost": {
          "items": {
            "$ref": "#/$defs/Hook"
          },
          "type": "array",
          "description": "VirtualToHost is a hook that is executed before syncing from the virtual to the host cluster"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "HostPathMapper": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled specifies if the host path mapper will be used"
        },
        "central": {
          "type": "boolean",
          "description": "Central specifies if the central host path mapper will be used"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "IPBlock": {
      "properties": {
        "cidr": {
          "type": "string",
          "description": "cidr is a string representing the IPBlock\nValid examples are \"192.168.1.0/24\" or \"2001:db8::/64\""
        },
        "except": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "except is a slice of CIDRs that should not be included within an IPBlock\nValid examples are \"192.168.1.0/24\" or \"2001:db8::/64\"\nExcept values will be rejected if they are outside the cidr range\n+optional"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Image": {
      "properties": {
        "registry": {
          "type": "string",
          "description": "Registry is the registry of the container image, e.g. my-registry.com or ghcr.io. This setting can be globally\noverridden via the controlPlane.advanced.defaultImageRegistry option. Empty means docker hub."
        },
        "repository": {
          "type": "string",
          "description": "Repository is the repository of the container image, e.g. my-repo/my-image"
        },
        "tag": {
          "type": "string",
          "description": "Tag is the tag of the container image, e.g. latest"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ImagePullSecretName": {
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the image pull secret to use."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Import": {
      "properties": {
        "apiVersion": {
          "type": "string",
          "description": "APIVersion of the object to sync"
        },
        "kind": {
          "type": "string",
          "description": "Kind of the object to sync"
        },
        "optional": {
          "type": "boolean"
        },
        "replaceOnConflict": {
          "type": "boolean",
          "description": "ReplaceWhenInvalid determines if the controller should try to recreate the object\nif there is a problem applying"
        },
        "patches": {
          "items": {
            "$ref": "#/$defs/Patch"
          },
          "type": "array",
          "description": "Patches are the patches to apply on the virtual cluster objects\nwhen syncing them from the host cluster"
        },
        "reversePatches": {
          "items": {
            "$ref": "#/$defs/Patch"
          },
          "type": "array",
          "description": "ReversePatches are the patches to apply to host cluster objects\nafter it has been synced to the virtual cluster"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "LabelsAndAnnotations": {
      "properties": {
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for this resource."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Labels are extra labels for this resource."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "LimitRange": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines if the limit range should be deployed by vCluster."
        },
        "default": {
          "type": "object",
          "description": "Default are the default limits for the limit range"
        },
        "defaultRequest": {
          "type": "object",
          "description": "DefaultRequest are the default request options for the limit range"
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for this resource."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Labels are extra labels for this resource."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "MetricsProxy": {
      "properties": {
        "nodes": {
          "type": "boolean",
          "description": "Nodes defines if metrics-server nodes api should get proxied from host to virtual cluster."
        },
        "pods": {
          "type": "boolean",
          "description": "Pods defines if metrics-server pods api should get proxied from host to virtual cluster."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "MutatingWebhook": {
      "properties": {
        "reinvocationPolicy": {
          "type": "string",
          "description": "reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.\nAllowed values are \"Never\" and \"IfNeeded\"."
        },
        "name": {
          "type": "string",
          "description": "The name of the admission webhook.\nName should be fully qualified, e.g., imagepolicy.kubernetes.io, where\n\"imagepolicy\" is the name of the webhook, and kubernetes.io is the name\nof the organization."
        },
        "clientConfig": {
          "$ref": "#/$defs/ValidatingWebhookClientConfig",
          "description": "ClientConfig defines how to communicate with the hook."
        },
        "rules": {
          "items": true,
          "type": "array",
          "description": "Rules describes what operations on what resources/subresources the webhook cares about.\nThe webhook cares about an operation if it matches _any_ Rule."
        },
        "failurePolicy": {
          "type": "string",
          "description": "FailurePolicy defines how unrecognized errors from the admission endpoint are handled -\nallowed values are Ignore or Fail. Defaults to Fail."
        },
        "matchPolicy": {
          "type": "string",
          "description": "matchPolicy defines how the \"rules\" list is used to match incoming requests.\nAllowed values are \"Exact\" or \"Equivalent\"."
        },
        "namespaceSelector": {
          "description": "NamespaceSelector decides whether to run the webhook on an object based\non whether the namespace for that object matches the selector. If the\nobject itself is a namespace, the matching is performed on\nobject.metadata.labels. If the object is another cluster scoped resource,\nit never skips the webhook."
        },
        "objectSelector": {
          "description": "ObjectSelector decides whether to run the webhook based on if the\nobject has matching labels. objectSelector is evaluated against both\nthe oldObject and newObject that would be sent to the webhook, and\nis considered to match if either object matches the selector."
        },
        "sideEffects": {
          "type": "string",
          "description": "SideEffects states whether this webhook has side effects."
        },
        "timeoutSeconds": {
          "type": "integer",
          "description": "TimeoutSeconds specifies the timeout for this webhook."
        },
        "admissionReviewVersions": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`\nversions the Webhook expects."
        },
        "matchConditions": {
          "items": true,
          "type": "array",
          "description": "MatchConditions is a list of conditions that must be met for a request to be sent to this\nwebhook. Match conditions filter requests that have already been matched by the rules,\nnamespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.\nThere are a maximum of 64 match conditions allowed."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "MutatingWebhookConfiguration": {
      "properties": {
        "kind": {
          "type": "string",
          "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to."
        },
        "apiVersion": {
          "type": "string",
          "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values."
        },
        "metadata": {
          "$ref": "#/$defs/ObjectMeta",
          "description": "Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata."
        },
        "webhooks": {
          "items": {
            "$ref": "#/$defs/MutatingWebhook"
          },
          "type": "array",
          "description": "Webhooks is a list of webhooks and the affected resources and operations."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "NetworkPolicy": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines if the network policy should be deployed by vCluster."
        },
        "fallbackDns": {
          "type": "string"
        },
        "outgoingConnections": {
          "$ref": "#/$defs/OutgoingConnections"
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for this resource."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Labels are extra labels for this resource."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "NetworkProxyKubelets": {
      "properties": {
        "byHostname": {
          "type": "boolean",
          "description": "ByHostname will add a special vCluster hostname to the nodes where the node can be reached at. This doesn't work\nfor all applications, e.g. Prometheus requires a node IP."
        },
        "byIP": {
          "type": "boolean",
          "description": "ByIP will create a separate service in the host cluster for every node that will point to virtual cluster and will be used to\nroute traffic."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Networking": {
      "properties": {
        "replicateServices": {
          "$ref": "#/$defs/ReplicateServices",
          "description": "ReplicateServices allows replicating services from the host within the virtual cluster or the other way around."
        },
        "resolveDNS": {
          "items": {
            "$ref": "#/$defs/ResolveDNS"
          },
          "type": "array",
          "description": "ResolveDNS allows to define extra DNS rules. This only works if embedded coredns is configured.",
          "pro": true
        },
        "advanced": {
          "$ref": "#/$defs/NetworkingAdvanced",
          "description": "Advanced holds advanced network options."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "NetworkingAdvanced": {
      "properties": {
        "clusterDomain": {
          "type": "string",
          "description": "ClusterDomain is the Kubernetes cluster domain to use within the virtual cluster."
        },
        "fallbackHostCluster": {
          "type": "boolean",
          "description": "FallbackHostCluster allows to fallback dns to the host cluster. This is useful if you want to reach host services without\nany other modification. You will need to provide a namespace for the service, e.g. my-other-service.my-other-namespace"
        },
        "proxyKubelets": {
          "$ref": "#/$defs/NetworkProxyKubelets",
          "description": "ProxyKubelets allows rewriting certain metrics and stats from the Kubelet to \"fake\" this for applications such as\nprometheus or other node exporters."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ObjectMeta": {
      "properties": {
        "name": {
          "type": "string",
          "description": "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services."
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Observability": {
      "properties": {
        "metrics": {
          "$ref": "#/$defs/ObservabilityMetrics",
          "description": "Metrics allows to proxy metrics server apis from host to virtual cluster."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ObservabilityMetrics": {
      "properties": {
        "proxy": {
          "$ref": "#/$defs/MetricsProxy",
          "description": "Proxy holds the configuration what metrics-server apis should get proxied."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "OutgoingConnections": {
      "properties": {
        "ipBlock": {
          "$ref": "#/$defs/IPBlock",
          "description": "IPBlock describes a particular CIDR (Ex. \"192.168.1.0/24\",\"2001:db8::/64\") that is allowed\nto the pods matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs\nthat should not be included within this rule."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Patch": {
      "properties": {
        "op": {
          "type": "string",
          "description": "Operation is the type of the patch"
        },
        "fromPath": {
          "type": "string",
          "description": "FromPath is the path from the other object"
        },
        "path": {
          "type": "string",
          "description": "Path is the path of the patch"
        },
        "namePath": {
          "type": "string",
          "description": "NamePath is the path to the name of a child resource within Path"
        },
        "namespacePath": {
          "type": "string",
          "description": "NamespacePath is path to the namespace of a child resource within Path"
        },
        "value": {
          "description": "Value is the new value to be set to the path"
        },
        "regex": {
          "type": "string",
          "description": "Regex - is regular expresion used to identify the Name,\nand optionally Namespace, parts of the field value that\nwill be replaced with the rewritten Name and/or Namespace"
        },
        "conditions": {
          "items": {
            "$ref": "#/$defs/PatchCondition"
          },
          "type": "array",
          "description": "Conditions are conditions that must be true for\nthe patch to get executed"
        },
        "ignore": {
          "type": "boolean",
          "description": "Ignore determines if the path should be ignored if handled as a reverse patch"
        },
        "sync": {
          "$ref": "#/$defs/PatchSync",
          "description": "Sync defines if a specialized syncer should be initialized using values\nfrom the rewriteName operation as Secret/Configmap names to be synced"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "PatchCondition": {
      "properties": {
        "path": {
          "type": "string",
          "description": "Path is the path within the object to select"
        },
        "subPath": {
          "type": "string",
          "description": "SubPath is the path below the selected object to select"
        },
        "equal": {
          "description": "Equal is the value the path should be equal to"
        },
        "notEqual": {
          "description": "NotEqual is the value the path should not be equal to"
        },
        "empty": {
          "type": "boolean",
          "description": "Empty means that the path value should be empty or unset"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "PatchSync": {
      "properties": {
        "secret": {
          "type": "boolean"
        },
        "configmap": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Platform": {
      "properties": {
        "api": {
          "$ref": "#/$defs/PlatformAPI",
          "description": "API defines how vCluster can contact the platform api."
        },
        "name": {
          "type": "string",
          "description": "Name is the name of the vCluster instance in the vCluster platform"
        },
        "owner": {
          "$ref": "#/$defs/PlatformOwner",
          "description": "Owner is the desired owner of the vCluster instance within the vCluster platform. If empty will take the current user."
        },
        "project": {
          "type": "string",
          "description": "Project is the project within the platform where the vCluster instance should connect."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "PlatformAPI": {
      "properties": {
        "accessKey": {
          "type": "string",
          "description": "AccessKey specifies the access key as a regular text value."
        },
        "host": {
          "type": "string",
          "description": "Host specifies the platform host to use."
        },
        "insecure": {
          "type": "boolean",
          "description": "Insecure specifies if the host uses a self-signed certificate."
        },
        "secretRef": {
          "$ref": "#/$defs/PlatformAccessKeySecretReference",
          "description": "SecretRef defines where to find the platform access key and host. By default, vCluster will search in the following locations in this precedence:\n* platform.api.accessKey\n* environment variable called LICENSE\n* secret specified under platform.api.secretRef.name\n* secret called \"vcluster-platform-api-key\" in the vCluster namespace"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "PlatformAccessKeySecretReference": {
      "properties": {
        "name": {
          "type": "string",
          "description": "Name is the name of the secret where the platform access key is stored. This defaults to vcluster-platform-api-key if undefined."
        },
        "namespace": {
          "type": "string",
          "description": "Namespace defines the namespace where the access key secret should be retrieved from. If this is not equal to the namespace\nwhere the vCluster instance is deployed, you need to make sure vCluster has access to this other namespace."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "description": "PlatformAccessKeySecretReference defines where to find the platform access key."
    },
    "PlatformOwner": {
      "properties": {
        "user": {
          "type": "string",
          "description": "User is the user id within the platform. This is mutually exclusive with team."
        },
        "team": {
          "type": "string",
          "description": "Team is the team id within the platform. This is mutually exclusive with user."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Plugin": {
      "properties": {
        "name": {
          "type": "string",
          "description": "Name is the name of the init-container and NOT the plugin name"
        },
        "image": {
          "type": "string",
          "description": "Image is the container image that should be used for the plugin"
        },
        "imagePullPolicy": {
          "type": "string",
          "description": "ImagePullPolicy is the pull policy to use for the container image"
        },
        "config": {
          "type": "object",
          "description": "Config is the plugin config to use. This can be arbitrary config used for the plugin."
        },
        "rbac": {
          "$ref": "#/$defs/PluginsRBAC",
          "description": "RBAC holds additional rbac configuration for the plugin"
        },
        "command": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Command is the command that should be used for the init container"
        },
        "args": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Args are the arguments that should be used for the init container"
        },
        "securityContext": {
          "type": "object",
          "description": "SecurityContext is the container security context used for the init container"
        },
        "resources": {
          "type": "object",
          "description": "Resources are the container resources used for the init container"
        },
        "volumeMounts": {
          "items": true,
          "type": "array",
          "description": "VolumeMounts are extra volume mounts for the init container"
        },
        "version": {
          "type": "string",
          "description": "Version is the plugin version, this is only needed for legacy plugins."
        },
        "env": {
          "items": true,
          "type": "array"
        },
        "envFrom": {
          "items": true,
          "type": "array"
        },
        "lifecycle": {
          "type": "object"
        },
        "livenessProbe": {
          "type": "object"
        },
        "readinessProbe": {
          "type": "object"
        },
        "startupProbe": {
          "type": "object"
        },
        "workingDir": {
          "type": "string"
        },
        "optional": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Plugins": {
      "properties": {
        "name": {
          "type": "string",
          "description": "Name is the name of the init-container and NOT the plugin name"
        },
        "image": {
          "type": "string",
          "description": "Image is the container image that should be used for the plugin"
        },
        "imagePullPolicy": {
          "type": "string",
          "description": "ImagePullPolicy is the pull policy to use for the container image"
        },
        "config": {
          "type": "object",
          "description": "Config is the plugin config to use. This can be arbitrary config used for the plugin."
        },
        "rbac": {
          "$ref": "#/$defs/PluginsRBAC",
          "description": "RBAC holds additional rbac configuration for the plugin"
        },
        "command": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Command is the command that should be used for the init container"
        },
        "args": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Args are the arguments that should be used for the init container"
        },
        "securityContext": {
          "type": "object",
          "description": "SecurityContext is the container security context used for the init container"
        },
        "resources": {
          "type": "object",
          "description": "Resources are the container resources used for the init container"
        },
        "volumeMounts": {
          "items": true,
          "type": "array",
          "description": "VolumeMounts are extra volume mounts for the init container"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "PluginsExtraRules": {
      "properties": {
        "extraRules": {
          "items": {
            "$ref": "#/$defs/RBACPolicyRule"
          },
          "type": "array",
          "description": "ExtraRules are extra rbac permissions roles that will be added to role or cluster role"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "PluginsRBAC": {
      "properties": {
        "role": {
          "$ref": "#/$defs/PluginsExtraRules",
          "description": "Role holds extra virtual cluster role permissions for the plugin"
        },
        "clusterRole": {
          "$ref": "#/$defs/PluginsExtraRules",
          "description": "ClusterRole holds extra virtual cluster cluster role permissions required for the plugin"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Policies": {
      "properties": {
        "networkPolicy": {
          "$ref": "#/$defs/NetworkPolicy",
          "description": "NetworkPolicy specifies network policy options."
        },
        "podSecurityStandard": {
          "type": "string",
          "description": "PodSecurityStandard that can be enforced can be one of: empty (\"\"), baseline, restricted or privileged"
        },
        "resourceQuota": {
          "$ref": "#/$defs/ResourceQuota",
          "description": "ResourceQuota specifies resource quota options."
        },
        "limitRange": {
          "$ref": "#/$defs/LimitRange",
          "description": "LimitRange specifies limit range options."
        },
        "centralAdmission": {
          "$ref": "#/$defs/CentralAdmission",
          "description": "CentralAdmission defines what validating or mutating webhooks should be enforced within the virtual cluster.",
          "pro": true
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "RBAC": {
      "properties": {
        "role": {
          "$ref": "#/$defs/RBACRole",
          "description": "Role holds virtual cluster role configuration"
        },
        "clusterRole": {
          "$ref": "#/$defs/RBACClusterRole",
          "description": "ClusterRole holds virtual cluster cluster role configuration"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "RBACClusterRole": {
      "properties": {
        "enabled": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "boolean"
            }
          ],
          "description": "Enabled defines if the cluster role should be enabled or disabled. If auto, vCluster automatically determines whether the virtual cluster requires a cluster role."
        },
        "extraRules": {
          "items": {
            "type": "object"
          },
          "type": "array",
          "description": "ExtraRules will add rules to the cluster role."
        },
        "overwriteRules": {
          "items": {
            "type": "object"
          },
          "type": "array",
          "description": "OverwriteRules will overwrite the cluster role rules completely."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "RBACPolicyRule": {
      "properties": {
        "verbs": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs."
        },
        "apiGroups": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of\nthe enumerated resources in any API group will be allowed. \"\" represents the core API group and \"*\" represents all API groups."
        },
        "resources": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Resources is a list of resources this rule applies to. '*' represents all resources."
        },
        "resourceNames": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed."
        },
        "nonResourceURLs": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path\nSince non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.\nRules can either apply to API resources (such as \"pods\" or \"secrets\") or non-resource URL paths (such as \"/api\"),  but not both."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "RBACRole": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines if the role should be enabled or disabled."
        },
        "extraRules": {
          "items": {
            "type": "object"
          },
          "type": "array",
          "description": "ExtraRules will add rules to the role."
        },
        "overwriteRules": {
          "items": {
            "type": "object"
          },
          "type": "array",
          "description": "OverwriteRules will overwrite the role rules completely."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ReplicateServices": {
      "properties": {
        "toHost": {
          "items": {
            "$ref": "#/$defs/ServiceMapping"
          },
          "type": "array",
          "description": "ToHost defines the services that should get synced from virtual cluster to the host cluster. If services are\nsynced to a different namespace than the virtual cluster is in, additional permissions for the other namespace\nare required."
        },
        "fromHost": {
          "items": {
            "$ref": "#/$defs/ServiceMapping"
          },
          "type": "array",
          "description": "FromHost defines the services that should get synced from the host to the virtual cluster."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ResolveDNS": {
      "properties": {
        "hostname": {
          "type": "string",
          "description": "Hostname is the hostname within the vCluster that should be resolved from."
        },
        "service": {
          "type": "string",
          "description": "Service is the virtual cluster service that should be resolved from."
        },
        "namespace": {
          "type": "string",
          "description": "Namespace is the virtual cluster namespace that should be resolved from."
        },
        "target": {
          "$ref": "#/$defs/ResolveDNSTarget",
          "description": "Target is the DNS target that should get mapped to"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ResolveDNSTarget": {
      "properties": {
        "hostname": {
          "type": "string",
          "description": "Hostname to use as a DNS target"
        },
        "ip": {
          "type": "string",
          "description": "IP to use as a DNS target"
        },
        "hostService": {
          "type": "string",
          "description": "HostService to target, format is hostNamespace/hostService"
        },
        "hostNamespace": {
          "type": "string",
          "description": "HostNamespace to target"
        },
        "vClusterService": {
          "type": "string",
          "description": "VClusterService format is hostNamespace/vClusterName/vClusterNamespace/vClusterService"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ResourceQuota": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines if the resource quota should be enabled."
        },
        "quota": {
          "type": "object",
          "description": "Quota are the quota options"
        },
        "scopeSelector": {
          "type": "object",
          "description": "ScopeSelector is the resource quota scope selector"
        },
        "scopes": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Scopes are the resource quota scopes"
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are extra annotations for this resource."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Labels are extra labels for this resource."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Resources": {
      "properties": {
        "limits": {
          "type": "object",
          "description": "Limits are resource limits for the container"
        },
        "requests": {
          "type": "object",
          "description": "Requests are minimal resources that will be consumed by the container"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "RuleWithVerbs": {
      "properties": {
        "apiGroups": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "APIGroups is the API groups the resources belong to. '*' is all groups."
        },
        "apiVersions": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "APIVersions is the API versions the resources belong to. '*' is all versions."
        },
        "resources": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Resources is a list of resources this rule applies to."
        },
        "scope": {
          "type": "string",
          "description": "Scope specifies the scope of this rule."
        },
        "operations": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "Verb is the kube verb associated with the request for API requests, not the http verb. This includes things like list and watch.\nFor non-resource requests, this is the lowercase http verb.\nIf '*' is present, the length of the slice must be one."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Selector": {
      "properties": {
        "labelSelector": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "LabelSelector are the labels to select the object from"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ServiceMapping": {
      "properties": {
        "from": {
          "type": "string",
          "description": "From is the service that should get synced. Can be either in the form name or namespace/name."
        },
        "to": {
          "type": "string",
          "description": "To is the target service that it should get synced to. Can be either in the form name or namespace/name."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ServiceMonitor": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled configures if Helm should create the service monitor."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Labels are the extra labels to add to the service monitor."
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Annotations are the extra annotations to add to the service monitor."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "StatefulSetImage": {
      "properties": {
        "registry": {
          "type": "string",
          "description": "Configure the registry of the container image, e.g. my-registry.com or ghcr.io\nIt defaults to ghcr.io and can be overriding either by using this field or controlPlane.advanced.defaultImageRegistry"
        },
        "repository": {
          "type": "string",
          "description": "Configure the repository of the container image, e.g. my-repo/my-image.\nIt defaults to the vCluster pro repository that includes the optional pro modules that are turned off by default.\nIf you still want to use the pure OSS build, use 'loft-sh/vcluster-oss' instead."
        },
        "tag": {
          "type": "string",
          "description": "Tag is the tag of the container image, e.g. latest"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Sync": {
      "properties": {
        "toHost": {
          "$ref": "#/$defs/SyncToHost",
          "description": "Configure resources to sync from the virtual cluster to the host cluster."
        },
        "fromHost": {
          "$ref": "#/$defs/SyncFromHost",
          "description": "Configure what resources vCluster should sync from the host cluster to the virtual cluster."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "SyncAllResource": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines if this option should be enabled."
        },
        "all": {
          "type": "boolean",
          "description": "All defines if all resources of that type should get synced or only the necessary ones that are needed."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "SyncFromHost": {
      "properties": {
        "nodes": {
          "$ref": "#/$defs/SyncNodes",
          "description": "Nodes defines if nodes should get synced from the host cluster to the virtual cluster, but not back."
        },
        "events": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "Events defines if events should get synced from the host cluster to the virtual cluster, but not back."
        },
        "ingressClasses": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "IngressClasses defines if ingress classes should get synced from the host cluster to the virtual cluster, but not back."
        },
        "storageClasses": {
          "$ref": "#/$defs/EnableAutoSwitch",
          "description": "StorageClasses defines if storage classes should get synced from the host cluster to the virtual cluster, but not back. If auto, is automatically enabled when the virtual scheduler is enabled."
        },
        "csiNodes": {
          "$ref": "#/$defs/EnableAutoSwitch",
          "description": "CSINodes defines if csi nodes should get synced from the host cluster to the virtual cluster, but not back. If auto, is automatically enabled when the virtual scheduler is enabled."
        },
        "csiDrivers": {
          "$ref": "#/$defs/EnableAutoSwitch",
          "description": "CSIDrivers defines if csi drivers should get synced from the host cluster to the virtual cluster, but not back. If auto, is automatically enabled when the virtual scheduler is enabled."
        },
        "csiStorageCapacities": {
          "$ref": "#/$defs/EnableAutoSwitch",
          "description": "CSIStorageCapacities defines if csi storage capacities should get synced from the host cluster to the virtual cluster, but not back. If auto, is automatically enabled when the virtual scheduler is enabled."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "SyncNodeSelector": {
      "properties": {
        "all": {
          "type": "boolean",
          "description": "All specifies if all nodes should get synced by vCluster from the host to the virtual cluster or only the ones where pods are assigned to."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "Labels are the node labels used to sync nodes from host cluster to virtual cluster. This will also set the node selector when syncing a pod from virtual cluster to host cluster to the same value."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "SyncNodes": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled specifies if syncing real nodes should be enabled. If this is disabled, vCluster will create fake nodes instead."
        },
        "syncBackChanges": {
          "type": "boolean",
          "description": "SyncBackChanges enables syncing labels and taints from the virtual cluster to the host cluster. If this is enabled someone within the virtual cluster will be able to change the labels and taints of the host cluster node."
        },
        "clearImageStatus": {
          "type": "boolean",
          "description": "ClearImageStatus will erase the image status when syncing a node. This allows to hide images that are pulled by the node."
        },
        "selector": {
          "$ref": "#/$defs/SyncNodeSelector",
          "description": "Selector can be used to define more granular what nodes should get synced from the host cluster to the virtual cluster."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "SyncPods": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled defines if pod syncing should be enabled."
        },
        "translateImage": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "description": "TranslateImage maps an image to another image that should be used instead. For example this can be used to rewrite\na certain image that is used within the virtual cluster to be another image on the host cluster"
        },
        "enforceTolerations": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "EnforceTolerations will add the specified tolerations to all pods synced by the virtual cluster."
        },
        "useSecretsForSATokens": {
          "type": "boolean",
          "description": "UseSecretsForSATokens will use secrets to save the generated service account tokens by virtual cluster instead of using a\npod annotation."
        },
        "rewriteHosts": {
          "$ref": "#/$defs/SyncRewriteHosts",
          "description": "RewriteHosts is a special option needed to rewrite statefulset containers to allow the correct FQDN. virtual cluster will add\na small container to each stateful set pod that will initially rewrite the /etc/hosts file to match the FQDN expected by\nthe virtual cluster."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "SyncRewriteHosts": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled specifies if rewriting stateful set pods should be enabled."
        },
        "initContainer": {
          "$ref": "#/$defs/SyncRewriteHostsInitContainer",
          "description": "InitContainer holds extra options for the init container used by vCluster to rewrite the FQDN for stateful set pods."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "SyncRewriteHostsInitContainer": {
      "properties": {
        "image": {
          "type": "string",
          "description": "Image is the image virtual cluster should use to rewrite this FQDN."
        },
        "resources": {
          "$ref": "#/$defs/Resources",
          "description": "Resources are the resources that should be assigned to the init container for each stateful set init container."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "SyncToHost": {
      "properties": {
        "pods": {
          "$ref": "#/$defs/SyncPods",
          "description": "Pods defines if pods created within the virtual cluster should get synced to the host cluster."
        },
        "secrets": {
          "$ref": "#/$defs/SyncAllResource",
          "description": "Secrets defines if secrets created within the virtual cluster should get synced to the host cluster."
        },
        "configMaps": {
          "$ref": "#/$defs/SyncAllResource",
          "description": "ConfigMaps defines if config maps created within the virtual cluster should get synced to the host cluster."
        },
        "ingresses": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "Ingresses defines if ingresses created within the virtual cluster should get synced to the host cluster."
        },
        "services": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "Services defines if services created within the virtual cluster should get synced to the host cluster."
        },
        "endpoints": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "Endpoints defines if endpoints created within the virtual cluster should get synced to the host cluster."
        },
        "networkPolicies": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "NetworkPolicies defines if network policies created within the virtual cluster should get synced to the host cluster."
        },
        "persistentVolumeClaims": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "PersistentVolumeClaims defines if persistent volume claims created within the virtual cluster should get synced to the host cluster."
        },
        "persistentVolumes": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "PersistentVolumes defines if persistent volumes created within the virtual cluster should get synced to the host cluster."
        },
        "volumeSnapshots": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "VolumeSnapshots defines if volume snapshots created within the virtual cluster should get synced to the host cluster."
        },
        "storageClasses": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "StorageClasses defines if storage classes created within the virtual cluster should get synced to the host cluster."
        },
        "serviceAccounts": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "ServiceAccounts defines if service accounts created within the virtual cluster should get synced to the host cluster."
        },
        "podDisruptionBudgets": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "PodDisruptionBudgets defines if pod disruption budgets created within the virtual cluster should get synced to the host cluster."
        },
        "priorityClasses": {
          "$ref": "#/$defs/EnableSwitch",
          "description": "PriorityClasses defines if priority classes created within the virtual cluster should get synced to the host cluster."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Telemetry": {
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Enabled specifies that the telemetry for the vCluster control plane should be enabled."
        },
        "instanceCreator": {
          "type": "string"
        },
        "machineID": {
          "type": "string"
        },
        "platformUserID": {
          "type": "string"
        },
        "platformInstanceID": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ValidatingWebhook": {
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the admission webhook.\nName should be fully qualified, e.g., imagepolicy.kubernetes.io, where\n\"imagepolicy\" is the name of the webhook, and kubernetes.io is the name\nof the organization."
        },
        "clientConfig": {
          "$ref": "#/$defs/ValidatingWebhookClientConfig",
          "description": "ClientConfig defines how to communicate with the hook."
        },
        "rules": {
          "items": true,
          "type": "array",
          "description": "Rules describes what operations on what resources/subresources the webhook cares about.\nThe webhook cares about an operation if it matches _any_ Rule."
        },
        "failurePolicy": {
          "type": "string",
          "description": "FailurePolicy defines how unrecognized errors from the admission endpoint are handled -\nallowed values are Ignore or Fail. Defaults to Fail."
        },
        "matchPolicy": {
          "type": "string",
          "description": "matchPolicy defines how the \"rules\" list is used to match incoming requests.\nAllowed values are \"Exact\" or \"Equivalent\"."
        },
        "namespaceSelector": {
          "description": "NamespaceSelector decides whether to run the webhook on an object based\non whether the namespace for that object matches the selector. If the\nobject itself is a namespace, the matching is performed on\nobject.metadata.labels. If the object is another cluster scoped resource,\nit never skips the webhook."
        },
        "objectSelector": {
          "description": "ObjectSelector decides whether to run the webhook based on if the\nobject has matching labels. objectSelector is evaluated against both\nthe oldObject and newObject that would be sent to the webhook, and\nis considered to match if either object matches the selector."
        },
        "sideEffects": {
          "type": "string",
          "description": "SideEffects states whether this webhook has side effects."
        },
        "timeoutSeconds": {
          "type": "integer",
          "description": "TimeoutSeconds specifies the timeout for this webhook."
        },
        "admissionReviewVersions": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`\nversions the Webhook expects."
        },
        "matchConditions": {
          "items": true,
          "type": "array",
          "description": "MatchConditions is a list of conditions that must be met for a request to be sent to this\nwebhook. Match conditions filter requests that have already been matched by the rules,\nnamespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.\nThere are a maximum of 64 match conditions allowed."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ValidatingWebhookClientConfig": {
      "properties": {
        "url": {
          "type": "string",
          "description": "URL gives the location of the webhook, in standard URL form\n(`scheme://host:port/path`). Exactly one of `url` or `service`\nmust be specified."
        },
        "service": {
          "$ref": "#/$defs/ValidatingWebhookServiceReference",
          "description": "Service is a reference to the service for this webhook. Either\n`service` or `url` must be specified.\n\nIf the webhook is running within the cluster, then you should use `service`."
        },
        "caBundle": {
          "type": "string",
          "contentEncoding": "base64",
          "description": "CABundle is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.\nIf unspecified, system trust roots on the apiserver are used."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "description": "ValidatingWebhookClientConfig contains the information to make a TLS connection with the webhook"
    },
    "ValidatingWebhookConfiguration": {
      "properties": {
        "kind": {
          "type": "string",
          "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to."
        },
        "apiVersion": {
          "type": "string",
          "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values."
        },
        "metadata": {
          "$ref": "#/$defs/ObjectMeta",
          "description": "Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata."
        },
        "webhooks": {
          "items": {
            "$ref": "#/$defs/ValidatingWebhook"
          },
          "type": "array",
          "description": "Webhooks is a list of webhooks and the affected resources and operations."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "ValidatingWebhookServiceReference": {
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace is the namespace of the service."
        },
        "name": {
          "type": "string",
          "description": "Name is the name of the service."
        },
        "path": {
          "type": "string",
          "description": "Path is an optional URL path which will be sent in any request to\nthis service."
        },
        "port": {
          "type": "integer",
          "description": "If specified, the port on the service that hosting webhook.\nDefault to 443 for backward compatibility.\n`port` should be a valid port number (1-65535, inclusive)."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "VirtualClusterKubeConfig": {
      "properties": {
        "kubeConfig": {
          "type": "string",
          "description": "KubeConfig is the virtual cluster kubeconfig path."
        },
        "serverCAKey": {
          "type": "string",
          "description": "ServerCAKey is the server ca key path."
        },
        "serverCACert": {
          "type": "string",
          "description": "ServerCAKey is the server ca cert path."
        },
        "clientCACert": {
          "type": "string",
          "description": "ServerCAKey is the client ca cert path."
        },
        "requestHeaderCACert": {
          "type": "string",
          "description": "RequestHeaderCACert is the request header ca cert path."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "VolumeClaim": {
      "properties": {
        "enabled": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "boolean"
            }
          ],
          "description": "Enabled enables deploying a persistent volume claim. If auto, vCluster will automatically determine\nbased on the chosen distro and other options if this is required."
        },
        "accessModes": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "AccessModes are the persistent volume claim access modes."
        },
        "retentionPolicy": {
          "type": "string",
          "description": "RetentionPolicy is the persistent volume claim retention policy."
        },
        "size": {
          "type": "string",
          "description": "Size is the persistent volume claim storage size."
        },
        "storageClass": {
          "type": "string",
          "description": "StorageClass is the persistent volume claim storage class."
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "VolumeMount": {
      "properties": {
        "name": {
          "type": "string",
          "description": "This must match the Name of a Volume."
        },
        "readOnly": {
          "type": "boolean",
          "description": "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false."
        },
        "mountPath": {
          "type": "string",
          "description": "Path within the container at which the volume should be mounted.  Must\nnot contain ':'."
        },
        "subPath": {
          "type": "string",
          "description": "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root)."
        },
        "mountPropagation": {
          "type": "string",
          "description": "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10."
        },
        "subPathExpr": {
          "type": "string",
          "description": "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive."
        }
      },
      "additionalProperties": false,
      "type": "object",
      "description": "VolumeMount describes a mounting of a Volume within a container."
    }
  },
  "properties": {
    "global": {
      "description": "Global values shared across all (sub)charts"
    },
    "exportKubeConfig": {
      "$ref": "#/$defs/ExportKubeConfig",
      "description": "ExportKubeConfig describes how vCluster should export the vCluster kubeConfig file."
    },
    "sync": {
      "$ref": "#/$defs/Sync",
      "description": "Sync describes how to sync resources from the virtual cluster to host cluster and back."
    },
    "networking": {
      "$ref": "#/$defs/Networking",
      "description": "Networking options related to the virtual cluster."
    },
    "policies": {
      "$ref": "#/$defs/Policies",
      "description": "Policies to enforce for the virtual cluster deployment as well as within the virtual cluster."
    },
    "observability": {
      "$ref": "#/$defs/Observability",
      "description": "Observability holds options to proxy metrics from the host cluster into the virtual cluster."
    },
    "controlPlane": {
      "$ref": "#/$defs/ControlPlane",
      "description": "Configure vCluster's control plane components and deployment."
    },
    "rbac": {
      "$ref": "#/$defs/RBAC",
      "description": "RBAC options for the virtual cluster."
    },
    "plugins": {
      "anyOf": [
        {
          "patternProperties": {
            ".*": {
              "type": "string"
            }
          },
          "type": "object"
        },
        {
          "type": "object"
        },
        {
          "type": "object"
        }
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Plugins"
      },
      "description": "Define which vCluster plugins to load."
    },
    "platform": {
      "$ref": "#/$defs/Platform",
      "description": "Platform holds options for connecting to vCluster Platform."
    },
    "experimental": {
      "$ref": "#/$defs/Experimental",
      "description": "Experimental features for vCluster. Configuration here might change, so be careful with this."
    },
    "telemetry": {
      "$ref": "#/$defs/Telemetry",
      "description": "Configuration related to telemetry gathered about vCluster usage."
    },
    "serviceCIDR": {
      "type": "string",
      "description": "ServiceCIDR holds the service cidr for the virtual cluster. Do not use this option anymore."
    },
    "pro": {
      "type": "boolean",
      "description": "Specifies whether to use vCluster Pro. This is automatically inferred in newer versions. Do not use that option anymore."
    },
    "plugin": {
      "anyOf": [
        {
          "patternProperties": {
            ".*": {
              "type": "string"
            }
          },
          "type": "object"
        },
        {
          "type": "object"
        },
        {
          "type": "object"
        }
      ],
      "additionalProperties": {
        "$ref": "#/$defs/Plugin"
      },
      "description": "Plugin specifies which vCluster plugins to enable. Use \"plugins\" instead. Do not use this option anymore."
    }
  },
  "additionalProperties": false,
  "type": "object",
  "description": "Config is the vCluster config."
}