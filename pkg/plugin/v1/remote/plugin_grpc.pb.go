// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.3
// source: plugin.proto

package remote

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// VClusterClient is the client API for VCluster service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VClusterClient interface {
	// Deprecated: Use GetContext & RegisterPlugin instead
	Register(ctx context.Context, in *PluginInfo, opts ...grpc.CallOption) (*Context, error)
	GetContext(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Context, error)
	RegisterPlugin(ctx context.Context, in *RegisterPluginRequest, opts ...grpc.CallOption) (*RegisterPluginResult, error)
	IsLeader(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*LeaderInfo, error)
}

type vClusterClient struct {
	cc grpc.ClientConnInterface
}

func NewVClusterClient(cc grpc.ClientConnInterface) VClusterClient {
	return &vClusterClient{cc}
}

func (c *vClusterClient) Register(ctx context.Context, in *PluginInfo, opts ...grpc.CallOption) (*Context, error) {
	out := new(Context)
	err := c.cc.Invoke(ctx, "/remote.VCluster/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vClusterClient) GetContext(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Context, error) {
	out := new(Context)
	err := c.cc.Invoke(ctx, "/remote.VCluster/GetContext", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vClusterClient) RegisterPlugin(ctx context.Context, in *RegisterPluginRequest, opts ...grpc.CallOption) (*RegisterPluginResult, error) {
	out := new(RegisterPluginResult)
	err := c.cc.Invoke(ctx, "/remote.VCluster/RegisterPlugin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vClusterClient) IsLeader(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*LeaderInfo, error) {
	out := new(LeaderInfo)
	err := c.cc.Invoke(ctx, "/remote.VCluster/IsLeader", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VClusterServer is the server API for VCluster service.
// All implementations must embed UnimplementedVClusterServer
// for forward compatibility
type VClusterServer interface {
	// Deprecated: Use GetContext & RegisterPlugin instead
	Register(context.Context, *PluginInfo) (*Context, error)
	GetContext(context.Context, *Empty) (*Context, error)
	RegisterPlugin(context.Context, *RegisterPluginRequest) (*RegisterPluginResult, error)
	IsLeader(context.Context, *Empty) (*LeaderInfo, error)
	mustEmbedUnimplementedVClusterServer()
}

// UnimplementedVClusterServer must be embedded to have forward compatible implementations.
type UnimplementedVClusterServer struct {
}

func (UnimplementedVClusterServer) Register(context.Context, *PluginInfo) (*Context, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedVClusterServer) GetContext(context.Context, *Empty) (*Context, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetContext not implemented")
}
func (UnimplementedVClusterServer) RegisterPlugin(context.Context, *RegisterPluginRequest) (*RegisterPluginResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterPlugin not implemented")
}
func (UnimplementedVClusterServer) IsLeader(context.Context, *Empty) (*LeaderInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsLeader not implemented")
}
func (UnimplementedVClusterServer) mustEmbedUnimplementedVClusterServer() {}

// UnsafeVClusterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VClusterServer will
// result in compilation errors.
type UnsafeVClusterServer interface {
	mustEmbedUnimplementedVClusterServer()
}

func RegisterVClusterServer(s grpc.ServiceRegistrar, srv VClusterServer) {
	s.RegisterService(&VCluster_ServiceDesc, srv)
}

func _VCluster_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VClusterServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remote.VCluster/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VClusterServer).Register(ctx, req.(*PluginInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCluster_GetContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VClusterServer).GetContext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remote.VCluster/GetContext",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VClusterServer).GetContext(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCluster_RegisterPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VClusterServer).RegisterPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remote.VCluster/RegisterPlugin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VClusterServer).RegisterPlugin(ctx, req.(*RegisterPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCluster_IsLeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VClusterServer).IsLeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remote.VCluster/IsLeader",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VClusterServer).IsLeader(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// VCluster_ServiceDesc is the grpc.ServiceDesc for VCluster service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VCluster_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "remote.VCluster",
	HandlerType: (*VClusterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _VCluster_Register_Handler,
		},
		{
			MethodName: "GetContext",
			Handler:    _VCluster_GetContext_Handler,
		},
		{
			MethodName: "RegisterPlugin",
			Handler:    _VCluster_RegisterPlugin_Handler,
		},
		{
			MethodName: "IsLeader",
			Handler:    _VCluster_IsLeader_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}

// PluginClient is the client API for Plugin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PluginClient interface {
	Mutate(ctx context.Context, in *MutateRequest, opts ...grpc.CallOption) (*MutateResult, error)
}

type pluginClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginClient(cc grpc.ClientConnInterface) PluginClient {
	return &pluginClient{cc}
}

func (c *pluginClient) Mutate(ctx context.Context, in *MutateRequest, opts ...grpc.CallOption) (*MutateResult, error) {
	out := new(MutateResult)
	err := c.cc.Invoke(ctx, "/remote.Plugin/Mutate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginServer is the server API for Plugin service.
// All implementations must embed UnimplementedPluginServer
// for forward compatibility
type PluginServer interface {
	Mutate(context.Context, *MutateRequest) (*MutateResult, error)
	mustEmbedUnimplementedPluginServer()
}

// UnimplementedPluginServer must be embedded to have forward compatible implementations.
type UnimplementedPluginServer struct {
}

func (UnimplementedPluginServer) Mutate(context.Context, *MutateRequest) (*MutateResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mutate not implemented")
}
func (UnimplementedPluginServer) mustEmbedUnimplementedPluginServer() {}

// UnsafePluginServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginServer will
// result in compilation errors.
type UnsafePluginServer interface {
	mustEmbedUnimplementedPluginServer()
}

func RegisterPluginServer(s grpc.ServiceRegistrar, srv PluginServer) {
	s.RegisterService(&Plugin_ServiceDesc, srv)
}

func _Plugin_Mutate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MutateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServer).Mutate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remote.Plugin/Mutate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServer).Mutate(ctx, req.(*MutateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Plugin_ServiceDesc is the grpc.ServiceDesc for Plugin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Plugin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "remote.Plugin",
	HandlerType: (*PluginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Mutate",
			Handler:    _Plugin_Mutate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}
