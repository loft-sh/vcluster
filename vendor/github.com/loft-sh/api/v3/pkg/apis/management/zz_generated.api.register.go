// Code generated by generator. DO NOT EDIT.

package management

import (
	"context"
	"fmt"

	pkglicenseapi "github.com/loft-sh/admin-apis/pkg/licenseapi"
	clusterv1 "github.com/loft-sh/agentapi/v3/pkg/apis/loft/cluster/v1"
	agentstoragev1 "github.com/loft-sh/agentapi/v3/pkg/apis/loft/storage/v1"
	auditv1 "github.com/loft-sh/api/v3/pkg/apis/audit/v1"
	storagev1 "github.com/loft-sh/api/v3/pkg/apis/storage/v1"
	uiv1 "github.com/loft-sh/api/v3/pkg/apis/ui/v1"
	"github.com/loft-sh/api/v3/pkg/managerfactory"
	"github.com/loft-sh/apiserver/pkg/builders"
	policyv1beta1 "github.com/loft-sh/jspolicy/pkg/apis/policy/v1beta1"
	authorizationv1 "k8s.io/api/authorization/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	"k8s.io/apimachinery/pkg/apis/meta/internalversion"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apiserver/pkg/registry/generic"
	"k8s.io/apiserver/pkg/registry/rest"
)

type NewRESTFunc func(factory managerfactory.SharedManagerFactory) rest.Storage

var (
	ManagementAgentAuditEventStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalAgentAuditEvent,
		func() runtime.Object { return &AgentAuditEvent{} },     // Register versioned resource
		func() runtime.Object { return &AgentAuditEventList{} }, // Register versioned resource list
		NewAgentAuditEventsREST,
	)
	NewAgentAuditEventsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewAgentAuditEventsRESTFunc(Factory)
	}
	NewAgentAuditEventsRESTFunc   NewRESTFunc
	ManagementAnnouncementStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalAnnouncement,
		func() runtime.Object { return &Announcement{} },     // Register versioned resource
		func() runtime.Object { return &AnnouncementList{} }, // Register versioned resource list
		NewAnnouncementREST,
	)
	NewAnnouncementREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewAnnouncementRESTFunc(Factory)
	}
	NewAnnouncementRESTFunc NewRESTFunc
	ManagementAppStorage    = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalApp,
		func() runtime.Object { return &App{} },     // Register versioned resource
		func() runtime.Object { return &AppList{} }, // Register versioned resource list
		NewAppREST,
	)
	NewAppREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewAppRESTFunc(Factory)
	}
	NewAppRESTFunc           NewRESTFunc
	ManagementClusterStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalCluster,
		func() runtime.Object { return &Cluster{} },     // Register versioned resource
		func() runtime.Object { return &ClusterList{} }, // Register versioned resource list
		NewClusterREST,
	)
	NewClusterREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterRESTFunc(Factory)
	}
	NewClusterRESTFunc             NewRESTFunc
	ManagementClusterAccessStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalClusterAccess,
		func() runtime.Object { return &ClusterAccess{} },     // Register versioned resource
		func() runtime.Object { return &ClusterAccessList{} }, // Register versioned resource list
		NewClusterAccessREST,
	)
	NewClusterAccessREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterAccessRESTFunc(Factory)
	}
	NewClusterAccessRESTFunc        NewRESTFunc
	ManagementClusterConnectStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalClusterConnect,
		func() runtime.Object { return &ClusterConnect{} },     // Register versioned resource
		func() runtime.Object { return &ClusterConnectList{} }, // Register versioned resource list
		NewClusterConnectREST,
	)
	NewClusterConnectREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterConnectRESTFunc(Factory)
	}
	NewClusterConnectRESTFunc            NewRESTFunc
	ManagementClusterRoleTemplateStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalClusterRoleTemplate,
		func() runtime.Object { return &ClusterRoleTemplate{} },     // Register versioned resource
		func() runtime.Object { return &ClusterRoleTemplateList{} }, // Register versioned resource list
		NewClusterRoleTemplateREST,
	)
	NewClusterRoleTemplateREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterRoleTemplateRESTFunc(Factory)
	}
	NewClusterRoleTemplateRESTFunc NewRESTFunc
	ManagementConfigStorage        = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalConfig,
		func() runtime.Object { return &Config{} },     // Register versioned resource
		func() runtime.Object { return &ConfigList{} }, // Register versioned resource list
		NewConfigREST,
	)
	NewConfigREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewConfigRESTFunc(Factory)
	}
	NewConfigRESTFunc                        NewRESTFunc
	ManagementDevPodWorkspaceInstanceStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalDevPodWorkspaceInstance,
		func() runtime.Object { return &DevPodWorkspaceInstance{} },     // Register versioned resource
		func() runtime.Object { return &DevPodWorkspaceInstanceList{} }, // Register versioned resource list
		NewDevPodWorkspaceInstanceREST,
	)
	NewDevPodWorkspaceInstanceREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceInstanceRESTFunc(Factory)
	}
	NewDevPodWorkspaceInstanceRESTFunc       NewRESTFunc
	ManagementDevPodWorkspaceTemplateStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalDevPodWorkspaceTemplate,
		func() runtime.Object { return &DevPodWorkspaceTemplate{} },     // Register versioned resource
		func() runtime.Object { return &DevPodWorkspaceTemplateList{} }, // Register versioned resource list
		NewDevPodWorkspaceTemplateREST,
	)
	NewDevPodWorkspaceTemplateREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceTemplateRESTFunc(Factory)
	}
	NewDevPodWorkspaceTemplateRESTFunc          NewRESTFunc
	ManagementDirectClusterEndpointTokenStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalDirectClusterEndpointToken,
		func() runtime.Object { return &DirectClusterEndpointToken{} },     // Register versioned resource
		func() runtime.Object { return &DirectClusterEndpointTokenList{} }, // Register versioned resource list
		NewDirectClusterEndpointTokenREST,
	)
	NewDirectClusterEndpointTokenREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDirectClusterEndpointTokenRESTFunc(Factory)
	}
	NewDirectClusterEndpointTokenRESTFunc NewRESTFunc
	ManagementEventStorage                = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalEvent,
		func() runtime.Object { return &Event{} },     // Register versioned resource
		func() runtime.Object { return &EventList{} }, // Register versioned resource list
		NewEventREST,
	)
	NewEventREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewEventRESTFunc(Factory)
	}
	NewEventRESTFunc         NewRESTFunc
	ManagementFeatureStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalFeature,
		func() runtime.Object { return &Feature{} },     // Register versioned resource
		func() runtime.Object { return &FeatureList{} }, // Register versioned resource list
		NewFeatureREST,
	)
	NewFeatureREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewFeatureRESTFunc(Factory)
	}
	NewFeatureRESTFunc                NewRESTFunc
	ManagementIngressAuthTokenStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalIngressAuthToken,
		func() runtime.Object { return &IngressAuthToken{} },     // Register versioned resource
		func() runtime.Object { return &IngressAuthTokenList{} }, // Register versioned resource list
		NewIngressAuthTokenREST,
	)
	NewIngressAuthTokenREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewIngressAuthTokenRESTFunc(Factory)
	}
	NewIngressAuthTokenRESTFunc NewRESTFunc
	ManagementKioskStorage      = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalKiosk,
		func() runtime.Object { return &Kiosk{} },     // Register versioned resource
		func() runtime.Object { return &KioskList{} }, // Register versioned resource list
		NewKioskREST,
	)
	NewKioskREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewKioskRESTFunc(Factory)
	}
	NewKioskRESTFunc         NewRESTFunc
	ManagementLicenseStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalLicense,
		func() runtime.Object { return &License{} },     // Register versioned resource
		func() runtime.Object { return &LicenseList{} }, // Register versioned resource list
		NewLicenseREST,
	)
	NewLicenseREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewLicenseRESTFunc(Factory)
	}
	NewLicenseRESTFunc            NewRESTFunc
	ManagementLicenseTokenStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalLicenseToken,
		func() runtime.Object { return &LicenseToken{} },     // Register versioned resource
		func() runtime.Object { return &LicenseTokenList{} }, // Register versioned resource list
		NewLicenseTokenREST,
	)
	NewLicenseTokenREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewLicenseTokenRESTFunc(Factory)
	}
	NewLicenseTokenRESTFunc      NewRESTFunc
	ManagementLoftUpgradeStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalLoftUpgrade,
		func() runtime.Object { return &LoftUpgrade{} },     // Register versioned resource
		func() runtime.Object { return &LoftUpgradeList{} }, // Register versioned resource list
		NewLoftUpgradeREST,
	)
	NewLoftUpgradeREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewLoftUpgradeRESTFunc(Factory)
	}
	NewLoftUpgradeRESTFunc          NewRESTFunc
	ManagementOwnedAccessKeyStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalOwnedAccessKey,
		func() runtime.Object { return &OwnedAccessKey{} },     // Register versioned resource
		func() runtime.Object { return &OwnedAccessKeyList{} }, // Register versioned resource list
		NewOwnedAccessKeyREST,
	)
	NewOwnedAccessKeyREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewOwnedAccessKeyRESTFunc(Factory)
	}
	NewOwnedAccessKeyRESTFunc        NewRESTFunc
	ManagementPolicyViolationStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalPolicyViolation,
		func() runtime.Object { return &PolicyViolation{} },     // Register versioned resource
		func() runtime.Object { return &PolicyViolationList{} }, // Register versioned resource list
		NewPolicyViolationREST,
	)
	NewPolicyViolationREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewPolicyViolationRESTFunc(Factory)
	}
	NewPolicyViolationRESTFunc NewRESTFunc
	ManagementProjectStorage   = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalProject,
		func() runtime.Object { return &Project{} },     // Register versioned resource
		func() runtime.Object { return &ProjectList{} }, // Register versioned resource list
		NewProjectREST,
	)
	NewProjectREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectRESTFunc(Factory)
	}
	NewProjectRESTFunc   NewRESTFunc
	NewProjectStatusREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectStatusRESTFunc(Factory)
	}
	NewProjectStatusRESTFunc       NewRESTFunc
	ManagementProjectSecretStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalProjectSecret,
		func() runtime.Object { return &ProjectSecret{} },     // Register versioned resource
		func() runtime.Object { return &ProjectSecretList{} }, // Register versioned resource list
		NewProjectSecretREST,
	)
	NewProjectSecretREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectSecretRESTFunc(Factory)
	}
	NewProjectSecretRESTFunc       NewRESTFunc
	ManagementRedirectTokenStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalRedirectToken,
		func() runtime.Object { return &RedirectToken{} },     // Register versioned resource
		func() runtime.Object { return &RedirectTokenList{} }, // Register versioned resource list
		NewRedirectTokenREST,
	)
	NewRedirectTokenREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewRedirectTokenRESTFunc(Factory)
	}
	NewRedirectTokenRESTFunc        NewRESTFunc
	ManagementResetAccessKeyStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalResetAccessKey,
		func() runtime.Object { return &ResetAccessKey{} },     // Register versioned resource
		func() runtime.Object { return &ResetAccessKeyList{} }, // Register versioned resource list
		NewResetAccessKeyREST,
	)
	NewResetAccessKeyREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewResetAccessKeyRESTFunc(Factory)
	}
	NewResetAccessKeyRESTFunc NewRESTFunc
	ManagementRunnerStorage   = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalRunner,
		func() runtime.Object { return &Runner{} },     // Register versioned resource
		func() runtime.Object { return &RunnerList{} }, // Register versioned resource list
		NewRunnerREST,
	)
	NewRunnerREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewRunnerRESTFunc(Factory)
	}
	NewRunnerRESTFunc   NewRESTFunc
	NewRunnerStatusREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewRunnerStatusRESTFunc(Factory)
	}
	NewRunnerStatusRESTFunc NewRESTFunc
	ManagementSelfStorage   = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSelf,
		func() runtime.Object { return &Self{} },     // Register versioned resource
		func() runtime.Object { return &SelfList{} }, // Register versioned resource list
		NewSelfREST,
	)
	NewSelfREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSelfRESTFunc(Factory)
	}
	NewSelfRESTFunc                          NewRESTFunc
	ManagementSelfSubjectAccessReviewStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSelfSubjectAccessReview,
		func() runtime.Object { return &SelfSubjectAccessReview{} },     // Register versioned resource
		func() runtime.Object { return &SelfSubjectAccessReviewList{} }, // Register versioned resource list
		NewSelfSubjectAccessReviewREST,
	)
	NewSelfSubjectAccessReviewREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSelfSubjectAccessReviewRESTFunc(Factory)
	}
	NewSelfSubjectAccessReviewRESTFunc NewRESTFunc
	ManagementSharedSecretStorage      = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSharedSecret,
		func() runtime.Object { return &SharedSecret{} },     // Register versioned resource
		func() runtime.Object { return &SharedSecretList{} }, // Register versioned resource list
		NewSharedSecretREST,
	)
	NewSharedSecretREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSharedSecretRESTFunc(Factory)
	}
	NewSharedSecretRESTFunc          NewRESTFunc
	ManagementSpaceConstraintStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSpaceConstraint,
		func() runtime.Object { return &SpaceConstraint{} },     // Register versioned resource
		func() runtime.Object { return &SpaceConstraintList{} }, // Register versioned resource list
		NewSpaceConstraintREST,
	)
	NewSpaceConstraintREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSpaceConstraintRESTFunc(Factory)
	}
	NewSpaceConstraintRESTFunc     NewRESTFunc
	ManagementSpaceInstanceStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSpaceInstance,
		func() runtime.Object { return &SpaceInstance{} },     // Register versioned resource
		func() runtime.Object { return &SpaceInstanceList{} }, // Register versioned resource list
		NewSpaceInstanceREST,
	)
	NewSpaceInstanceREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSpaceInstanceRESTFunc(Factory)
	}
	NewSpaceInstanceRESTFunc       NewRESTFunc
	ManagementSpaceTemplateStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSpaceTemplate,
		func() runtime.Object { return &SpaceTemplate{} },     // Register versioned resource
		func() runtime.Object { return &SpaceTemplateList{} }, // Register versioned resource list
		NewSpaceTemplateREST,
	)
	NewSpaceTemplateREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSpaceTemplateRESTFunc(Factory)
	}
	NewSpaceTemplateRESTFunc             NewRESTFunc
	ManagementSubjectAccessReviewStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSubjectAccessReview,
		func() runtime.Object { return &SubjectAccessReview{} },     // Register versioned resource
		func() runtime.Object { return &SubjectAccessReviewList{} }, // Register versioned resource list
		NewSubjectAccessReviewREST,
	)
	NewSubjectAccessReviewREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSubjectAccessReviewRESTFunc(Factory)
	}
	NewSubjectAccessReviewRESTFunc NewRESTFunc
	ManagementTaskStorage          = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalTask,
		func() runtime.Object { return &Task{} },     // Register versioned resource
		func() runtime.Object { return &TaskList{} }, // Register versioned resource list
		NewTaskREST,
	)
	NewTaskREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTaskRESTFunc(Factory)
	}
	NewTaskRESTFunc       NewRESTFunc
	ManagementTeamStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalTeam,
		func() runtime.Object { return &Team{} },     // Register versioned resource
		func() runtime.Object { return &TeamList{} }, // Register versioned resource list
		NewTeamREST,
	)
	NewTeamREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTeamRESTFunc(Factory)
	}
	NewTeamRESTFunc       NewRESTFunc
	ManagementUserStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalUser,
		func() runtime.Object { return &User{} },     // Register versioned resource
		func() runtime.Object { return &UserList{} }, // Register versioned resource list
		NewUserREST,
	)
	NewUserREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserRESTFunc(Factory)
	}
	NewUserRESTFunc                         NewRESTFunc
	ManagementVirtualClusterInstanceStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalVirtualClusterInstance,
		func() runtime.Object { return &VirtualClusterInstance{} },     // Register versioned resource
		func() runtime.Object { return &VirtualClusterInstanceList{} }, // Register versioned resource list
		NewVirtualClusterInstanceREST,
	)
	NewVirtualClusterInstanceREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewVirtualClusterInstanceRESTFunc(Factory)
	}
	NewVirtualClusterInstanceRESTFunc       NewRESTFunc
	ManagementVirtualClusterTemplateStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalVirtualClusterTemplate,
		func() runtime.Object { return &VirtualClusterTemplate{} },     // Register versioned resource
		func() runtime.Object { return &VirtualClusterTemplateList{} }, // Register versioned resource list
		NewVirtualClusterTemplateREST,
	)
	NewVirtualClusterTemplateREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewVirtualClusterTemplateRESTFunc(Factory)
	}
	NewVirtualClusterTemplateRESTFunc NewRESTFunc
	InternalAgentAuditEvent           = builders.NewInternalResource(
		"agentauditevents",
		"AgentAuditEvent",
		func() runtime.Object { return &AgentAuditEvent{} },
		func() runtime.Object { return &AgentAuditEventList{} },
	)
	InternalAgentAuditEventStatus = builders.NewInternalResourceStatus(
		"agentauditevents",
		"AgentAuditEventStatus",
		func() runtime.Object { return &AgentAuditEvent{} },
		func() runtime.Object { return &AgentAuditEventList{} },
	)
	InternalAnnouncement = builders.NewInternalResource(
		"announcements",
		"Announcement",
		func() runtime.Object { return &Announcement{} },
		func() runtime.Object { return &AnnouncementList{} },
	)
	InternalAnnouncementStatus = builders.NewInternalResourceStatus(
		"announcements",
		"AnnouncementStatus",
		func() runtime.Object { return &Announcement{} },
		func() runtime.Object { return &AnnouncementList{} },
	)
	InternalApp = builders.NewInternalResource(
		"apps",
		"App",
		func() runtime.Object { return &App{} },
		func() runtime.Object { return &AppList{} },
	)
	InternalAppStatus = builders.NewInternalResourceStatus(
		"apps",
		"AppStatus",
		func() runtime.Object { return &App{} },
		func() runtime.Object { return &AppList{} },
	)
	InternalCluster = builders.NewInternalResource(
		"clusters",
		"Cluster",
		func() runtime.Object { return &Cluster{} },
		func() runtime.Object { return &ClusterList{} },
	)
	InternalClusterStatus = builders.NewInternalResourceStatus(
		"clusters",
		"ClusterStatus",
		func() runtime.Object { return &Cluster{} },
		func() runtime.Object { return &ClusterList{} },
	)
	InternalClusterAgentConfigREST = builders.NewInternalSubresource(
		"clusters", "ClusterAgentConfig", "agentconfig",
		func() runtime.Object { return &ClusterAgentConfig{} },
	)
	NewClusterAgentConfigREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterAgentConfigRESTFunc(Factory)
	}
	NewClusterAgentConfigRESTFunc NewRESTFunc
	InternalClusterChartsREST     = builders.NewInternalSubresource(
		"clusters", "ClusterCharts", "charts",
		func() runtime.Object { return &ClusterCharts{} },
	)
	NewClusterChartsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterChartsRESTFunc(Factory)
	}
	NewClusterChartsRESTFunc  NewRESTFunc
	InternalClusterDomainREST = builders.NewInternalSubresource(
		"clusters", "ClusterDomain", "domain",
		func() runtime.Object { return &ClusterDomain{} },
	)
	NewClusterDomainREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterDomainRESTFunc(Factory)
	}
	NewClusterDomainRESTFunc        NewRESTFunc
	InternalClusterMemberAccessREST = builders.NewInternalSubresource(
		"clusters", "ClusterMemberAccess", "memberaccess",
		func() runtime.Object { return &ClusterMemberAccess{} },
	)
	NewClusterMemberAccessREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterMemberAccessRESTFunc(Factory)
	}
	NewClusterMemberAccessRESTFunc NewRESTFunc
	InternalClusterMembersREST     = builders.NewInternalSubresource(
		"clusters", "ClusterMembers", "members",
		func() runtime.Object { return &ClusterMembers{} },
	)
	NewClusterMembersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterMembersRESTFunc(Factory)
	}
	NewClusterMembersRESTFunc NewRESTFunc
	InternalClusterResetREST  = builders.NewInternalSubresource(
		"clusters", "ClusterReset", "reset",
		func() runtime.Object { return &ClusterReset{} },
	)
	NewClusterResetREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterResetRESTFunc(Factory)
	}
	NewClusterResetRESTFunc                   NewRESTFunc
	InternalClusterVirtualClusterDefaultsREST = builders.NewInternalSubresource(
		"clusters", "ClusterVirtualClusterDefaults", "virtualclusterdefaults",
		func() runtime.Object { return &ClusterVirtualClusterDefaults{} },
	)
	NewClusterVirtualClusterDefaultsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterVirtualClusterDefaultsRESTFunc(Factory)
	}
	NewClusterVirtualClusterDefaultsRESTFunc NewRESTFunc
	InternalClusterAccess                    = builders.NewInternalResource(
		"clusteraccesses",
		"ClusterAccess",
		func() runtime.Object { return &ClusterAccess{} },
		func() runtime.Object { return &ClusterAccessList{} },
	)
	InternalClusterAccessStatus = builders.NewInternalResourceStatus(
		"clusteraccesses",
		"ClusterAccessStatus",
		func() runtime.Object { return &ClusterAccess{} },
		func() runtime.Object { return &ClusterAccessList{} },
	)
	InternalClusterConnect = builders.NewInternalResource(
		"clusterconnect",
		"ClusterConnect",
		func() runtime.Object { return &ClusterConnect{} },
		func() runtime.Object { return &ClusterConnectList{} },
	)
	InternalClusterConnectStatus = builders.NewInternalResourceStatus(
		"clusterconnect",
		"ClusterConnectStatus",
		func() runtime.Object { return &ClusterConnect{} },
		func() runtime.Object { return &ClusterConnectList{} },
	)
	InternalClusterRoleTemplate = builders.NewInternalResource(
		"clusterroletemplates",
		"ClusterRoleTemplate",
		func() runtime.Object { return &ClusterRoleTemplate{} },
		func() runtime.Object { return &ClusterRoleTemplateList{} },
	)
	InternalClusterRoleTemplateStatus = builders.NewInternalResourceStatus(
		"clusterroletemplates",
		"ClusterRoleTemplateStatus",
		func() runtime.Object { return &ClusterRoleTemplate{} },
		func() runtime.Object { return &ClusterRoleTemplateList{} },
	)
	InternalConfig = builders.NewInternalResource(
		"configs",
		"Config",
		func() runtime.Object { return &Config{} },
		func() runtime.Object { return &ConfigList{} },
	)
	InternalConfigStatus = builders.NewInternalResourceStatus(
		"configs",
		"ConfigStatus",
		func() runtime.Object { return &Config{} },
		func() runtime.Object { return &ConfigList{} },
	)
	InternalDevPodWorkspaceInstance = builders.NewInternalResource(
		"devpodworkspaceinstances",
		"DevPodWorkspaceInstance",
		func() runtime.Object { return &DevPodWorkspaceInstance{} },
		func() runtime.Object { return &DevPodWorkspaceInstanceList{} },
	)
	InternalDevPodWorkspaceInstanceStatus = builders.NewInternalResourceStatus(
		"devpodworkspaceinstances",
		"DevPodWorkspaceInstanceStatus",
		func() runtime.Object { return &DevPodWorkspaceInstance{} },
		func() runtime.Object { return &DevPodWorkspaceInstanceList{} },
	)
	InternalDevPodWorkspaceInstanceDeleteREST = builders.NewInternalSubresource(
		"devpodworkspaceinstances", "DevPodWorkspaceInstanceDelete", "delete",
		func() runtime.Object { return &DevPodWorkspaceInstanceDelete{} },
	)
	NewDevPodWorkspaceInstanceDeleteREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceInstanceDeleteRESTFunc(Factory)
	}
	NewDevPodWorkspaceInstanceDeleteRESTFunc     NewRESTFunc
	InternalDevPodWorkspaceInstanceGetStatusREST = builders.NewInternalSubresource(
		"devpodworkspaceinstances", "DevPodWorkspaceInstanceGetStatus", "getstatus",
		func() runtime.Object { return &DevPodWorkspaceInstanceGetStatus{} },
	)
	NewDevPodWorkspaceInstanceGetStatusREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceInstanceGetStatusRESTFunc(Factory)
	}
	NewDevPodWorkspaceInstanceGetStatusRESTFunc NewRESTFunc
	InternalDevPodWorkspaceInstanceSshREST      = builders.NewInternalSubresource(
		"devpodworkspaceinstances", "DevPodWorkspaceInstanceSsh", "ssh",
		func() runtime.Object { return &DevPodWorkspaceInstanceSsh{} },
	)
	NewDevPodWorkspaceInstanceSshREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceInstanceSshRESTFunc(Factory)
	}
	NewDevPodWorkspaceInstanceSshRESTFunc   NewRESTFunc
	InternalDevPodWorkspaceInstanceStopREST = builders.NewInternalSubresource(
		"devpodworkspaceinstances", "DevPodWorkspaceInstanceStop", "stop",
		func() runtime.Object { return &DevPodWorkspaceInstanceStop{} },
	)
	NewDevPodWorkspaceInstanceStopREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceInstanceStopRESTFunc(Factory)
	}
	NewDevPodWorkspaceInstanceStopRESTFunc NewRESTFunc
	InternalDevPodWorkspaceInstanceUpREST  = builders.NewInternalSubresource(
		"devpodworkspaceinstances", "DevPodWorkspaceInstanceUp", "up",
		func() runtime.Object { return &DevPodWorkspaceInstanceUp{} },
	)
	NewDevPodWorkspaceInstanceUpREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceInstanceUpRESTFunc(Factory)
	}
	NewDevPodWorkspaceInstanceUpRESTFunc NewRESTFunc
	InternalDevPodWorkspaceTemplate      = builders.NewInternalResource(
		"devpodworkspacetemplates",
		"DevPodWorkspaceTemplate",
		func() runtime.Object { return &DevPodWorkspaceTemplate{} },
		func() runtime.Object { return &DevPodWorkspaceTemplateList{} },
	)
	InternalDevPodWorkspaceTemplateStatus = builders.NewInternalResourceStatus(
		"devpodworkspacetemplates",
		"DevPodWorkspaceTemplateStatus",
		func() runtime.Object { return &DevPodWorkspaceTemplate{} },
		func() runtime.Object { return &DevPodWorkspaceTemplateList{} },
	)
	InternalDirectClusterEndpointToken = builders.NewInternalResource(
		"directclusterendpointtokens",
		"DirectClusterEndpointToken",
		func() runtime.Object { return &DirectClusterEndpointToken{} },
		func() runtime.Object { return &DirectClusterEndpointTokenList{} },
	)
	InternalDirectClusterEndpointTokenStatus = builders.NewInternalResourceStatus(
		"directclusterendpointtokens",
		"DirectClusterEndpointTokenStatus",
		func() runtime.Object { return &DirectClusterEndpointToken{} },
		func() runtime.Object { return &DirectClusterEndpointTokenList{} },
	)
	InternalEvent = builders.NewInternalResource(
		"events",
		"Event",
		func() runtime.Object { return &Event{} },
		func() runtime.Object { return &EventList{} },
	)
	InternalEventStatus = builders.NewInternalResourceStatus(
		"events",
		"EventStatus",
		func() runtime.Object { return &Event{} },
		func() runtime.Object { return &EventList{} },
	)
	InternalFeature = builders.NewInternalResource(
		"features",
		"Feature",
		func() runtime.Object { return &Feature{} },
		func() runtime.Object { return &FeatureList{} },
	)
	InternalFeatureStatus = builders.NewInternalResourceStatus(
		"features",
		"FeatureStatus",
		func() runtime.Object { return &Feature{} },
		func() runtime.Object { return &FeatureList{} },
	)
	InternalIngressAuthToken = builders.NewInternalResource(
		"ingressauthtokens",
		"IngressAuthToken",
		func() runtime.Object { return &IngressAuthToken{} },
		func() runtime.Object { return &IngressAuthTokenList{} },
	)
	InternalIngressAuthTokenStatus = builders.NewInternalResourceStatus(
		"ingressauthtokens",
		"IngressAuthTokenStatus",
		func() runtime.Object { return &IngressAuthToken{} },
		func() runtime.Object { return &IngressAuthTokenList{} },
	)
	InternalKiosk = builders.NewInternalResource(
		"kiosk",
		"Kiosk",
		func() runtime.Object { return &Kiosk{} },
		func() runtime.Object { return &KioskList{} },
	)
	InternalKioskStatus = builders.NewInternalResourceStatus(
		"kiosk",
		"KioskStatus",
		func() runtime.Object { return &Kiosk{} },
		func() runtime.Object { return &KioskList{} },
	)
	InternalLicense = builders.NewInternalResource(
		"licenses",
		"License",
		func() runtime.Object { return &License{} },
		func() runtime.Object { return &LicenseList{} },
	)
	InternalLicenseStatus = builders.NewInternalResourceStatus(
		"licenses",
		"LicenseStatus",
		func() runtime.Object { return &License{} },
		func() runtime.Object { return &LicenseList{} },
	)
	InternalLicenseRequestREST = builders.NewInternalSubresource(
		"licenses", "LicenseRequest", "request",
		func() runtime.Object { return &LicenseRequest{} },
	)
	NewLicenseRequestREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewLicenseRequestRESTFunc(Factory)
	}
	NewLicenseRequestRESTFunc NewRESTFunc
	InternalLicenseToken      = builders.NewInternalResource(
		"licensetokens",
		"LicenseToken",
		func() runtime.Object { return &LicenseToken{} },
		func() runtime.Object { return &LicenseTokenList{} },
	)
	InternalLicenseTokenStatus = builders.NewInternalResourceStatus(
		"licensetokens",
		"LicenseTokenStatus",
		func() runtime.Object { return &LicenseToken{} },
		func() runtime.Object { return &LicenseTokenList{} },
	)
	InternalLoftUpgrade = builders.NewInternalResource(
		"loftupgrades",
		"LoftUpgrade",
		func() runtime.Object { return &LoftUpgrade{} },
		func() runtime.Object { return &LoftUpgradeList{} },
	)
	InternalLoftUpgradeStatus = builders.NewInternalResourceStatus(
		"loftupgrades",
		"LoftUpgradeStatus",
		func() runtime.Object { return &LoftUpgrade{} },
		func() runtime.Object { return &LoftUpgradeList{} },
	)
	InternalOwnedAccessKey = builders.NewInternalResource(
		"ownedaccesskeys",
		"OwnedAccessKey",
		func() runtime.Object { return &OwnedAccessKey{} },
		func() runtime.Object { return &OwnedAccessKeyList{} },
	)
	InternalOwnedAccessKeyStatus = builders.NewInternalResourceStatus(
		"ownedaccesskeys",
		"OwnedAccessKeyStatus",
		func() runtime.Object { return &OwnedAccessKey{} },
		func() runtime.Object { return &OwnedAccessKeyList{} },
	)
	InternalPolicyViolation = builders.NewInternalResource(
		"policyviolations",
		"PolicyViolation",
		func() runtime.Object { return &PolicyViolation{} },
		func() runtime.Object { return &PolicyViolationList{} },
	)
	InternalPolicyViolationStatus = builders.NewInternalResourceStatus(
		"policyviolations",
		"PolicyViolationStatus",
		func() runtime.Object { return &PolicyViolation{} },
		func() runtime.Object { return &PolicyViolationList{} },
	)
	InternalProject = builders.NewInternalResource(
		"projects",
		"Project",
		func() runtime.Object { return &Project{} },
		func() runtime.Object { return &ProjectList{} },
	)
	InternalProjectStatus = builders.NewInternalResourceStatus(
		"projects",
		"ProjectStatus",
		func() runtime.Object { return &Project{} },
		func() runtime.Object { return &ProjectList{} },
	)
	InternalProjectChartInfoREST = builders.NewInternalSubresource(
		"projects", "ProjectChartInfo", "chartinfo",
		func() runtime.Object { return &ProjectChartInfo{} },
	)
	NewProjectChartInfoREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectChartInfoRESTFunc(Factory)
	}
	NewProjectChartInfoRESTFunc NewRESTFunc
	InternalProjectChartsREST   = builders.NewInternalSubresource(
		"projects", "ProjectCharts", "charts",
		func() runtime.Object { return &ProjectCharts{} },
	)
	NewProjectChartsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectChartsRESTFunc(Factory)
	}
	NewProjectChartsRESTFunc    NewRESTFunc
	InternalProjectClustersREST = builders.NewInternalSubresource(
		"projects", "ProjectClusters", "clusters",
		func() runtime.Object { return &ProjectClusters{} },
	)
	NewProjectClustersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectClustersRESTFunc(Factory)
	}
	NewProjectClustersRESTFunc     NewRESTFunc
	InternalProjectImportSpaceREST = builders.NewInternalSubresource(
		"projects", "ProjectImportSpace", "importspace",
		func() runtime.Object { return &ProjectImportSpace{} },
	)
	NewProjectImportSpaceREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectImportSpaceRESTFunc(Factory)
	}
	NewProjectImportSpaceRESTFunc           NewRESTFunc
	InternalProjectImportVirtualClusterREST = builders.NewInternalSubresource(
		"projects", "ProjectImportVirtualCluster", "importvirtualcluster",
		func() runtime.Object { return &ProjectImportVirtualCluster{} },
	)
	NewProjectImportVirtualClusterREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectImportVirtualClusterRESTFunc(Factory)
	}
	NewProjectImportVirtualClusterRESTFunc NewRESTFunc
	InternalProjectMembersREST             = builders.NewInternalSubresource(
		"projects", "ProjectMembers", "members",
		func() runtime.Object { return &ProjectMembers{} },
	)
	NewProjectMembersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectMembersRESTFunc(Factory)
	}
	NewProjectMembersRESTFunc               NewRESTFunc
	InternalProjectMigrateSpaceInstanceREST = builders.NewInternalSubresource(
		"projects", "ProjectMigrateSpaceInstance", "migratespaceinstance",
		func() runtime.Object { return &ProjectMigrateSpaceInstance{} },
	)
	NewProjectMigrateSpaceInstanceREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectMigrateSpaceInstanceRESTFunc(Factory)
	}
	NewProjectMigrateSpaceInstanceRESTFunc           NewRESTFunc
	InternalProjectMigrateVirtualClusterInstanceREST = builders.NewInternalSubresource(
		"projects", "ProjectMigrateVirtualClusterInstance", "migratevirtualclusterinstance",
		func() runtime.Object { return &ProjectMigrateVirtualClusterInstance{} },
	)
	NewProjectMigrateVirtualClusterInstanceREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectMigrateVirtualClusterInstanceRESTFunc(Factory)
	}
	NewProjectMigrateVirtualClusterInstanceRESTFunc NewRESTFunc
	InternalProjectTemplatesREST                    = builders.NewInternalSubresource(
		"projects", "ProjectTemplates", "templates",
		func() runtime.Object { return &ProjectTemplates{} },
	)
	NewProjectTemplatesREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectTemplatesRESTFunc(Factory)
	}
	NewProjectTemplatesRESTFunc NewRESTFunc
	InternalProjectSecret       = builders.NewInternalResource(
		"projectsecrets",
		"ProjectSecret",
		func() runtime.Object { return &ProjectSecret{} },
		func() runtime.Object { return &ProjectSecretList{} },
	)
	InternalProjectSecretStatus = builders.NewInternalResourceStatus(
		"projectsecrets",
		"ProjectSecretStatus",
		func() runtime.Object { return &ProjectSecret{} },
		func() runtime.Object { return &ProjectSecretList{} },
	)
	InternalRedirectToken = builders.NewInternalResource(
		"redirecttokens",
		"RedirectToken",
		func() runtime.Object { return &RedirectToken{} },
		func() runtime.Object { return &RedirectTokenList{} },
	)
	InternalRedirectTokenStatus = builders.NewInternalResourceStatus(
		"redirecttokens",
		"RedirectTokenStatus",
		func() runtime.Object { return &RedirectToken{} },
		func() runtime.Object { return &RedirectTokenList{} },
	)
	InternalResetAccessKey = builders.NewInternalResource(
		"resetaccesskeys",
		"ResetAccessKey",
		func() runtime.Object { return &ResetAccessKey{} },
		func() runtime.Object { return &ResetAccessKeyList{} },
	)
	InternalResetAccessKeyStatus = builders.NewInternalResourceStatus(
		"resetaccesskeys",
		"ResetAccessKeyStatus",
		func() runtime.Object { return &ResetAccessKey{} },
		func() runtime.Object { return &ResetAccessKeyList{} },
	)
	InternalRunner = builders.NewInternalResource(
		"runners",
		"Runner",
		func() runtime.Object { return &Runner{} },
		func() runtime.Object { return &RunnerList{} },
	)
	InternalRunnerStatus = builders.NewInternalResourceStatus(
		"runners",
		"RunnerStatus",
		func() runtime.Object { return &Runner{} },
		func() runtime.Object { return &RunnerList{} },
	)
	InternalRunnerAccessKeyREST = builders.NewInternalSubresource(
		"runners", "RunnerAccessKey", "accesskey",
		func() runtime.Object { return &RunnerAccessKey{} },
	)
	NewRunnerAccessKeyREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewRunnerAccessKeyRESTFunc(Factory)
	}
	NewRunnerAccessKeyRESTFunc NewRESTFunc
	InternalRunnerConfigREST   = builders.NewInternalSubresource(
		"runners", "RunnerConfig", "config",
		func() runtime.Object { return &RunnerConfig{} },
	)
	NewRunnerConfigREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewRunnerConfigRESTFunc(Factory)
	}
	NewRunnerConfigRESTFunc NewRESTFunc
	InternalSelf            = builders.NewInternalResource(
		"selves",
		"Self",
		func() runtime.Object { return &Self{} },
		func() runtime.Object { return &SelfList{} },
	)
	InternalSelfStatus = builders.NewInternalResourceStatus(
		"selves",
		"SelfStatus",
		func() runtime.Object { return &Self{} },
		func() runtime.Object { return &SelfList{} },
	)
	InternalSelfSubjectAccessReview = builders.NewInternalResource(
		"selfsubjectaccessreviews",
		"SelfSubjectAccessReview",
		func() runtime.Object { return &SelfSubjectAccessReview{} },
		func() runtime.Object { return &SelfSubjectAccessReviewList{} },
	)
	InternalSelfSubjectAccessReviewStatus = builders.NewInternalResourceStatus(
		"selfsubjectaccessreviews",
		"SelfSubjectAccessReviewStatus",
		func() runtime.Object { return &SelfSubjectAccessReview{} },
		func() runtime.Object { return &SelfSubjectAccessReviewList{} },
	)
	InternalSharedSecret = builders.NewInternalResource(
		"sharedsecrets",
		"SharedSecret",
		func() runtime.Object { return &SharedSecret{} },
		func() runtime.Object { return &SharedSecretList{} },
	)
	InternalSharedSecretStatus = builders.NewInternalResourceStatus(
		"sharedsecrets",
		"SharedSecretStatus",
		func() runtime.Object { return &SharedSecret{} },
		func() runtime.Object { return &SharedSecretList{} },
	)
	InternalSpaceConstraint = builders.NewInternalResource(
		"spaceconstraints",
		"SpaceConstraint",
		func() runtime.Object { return &SpaceConstraint{} },
		func() runtime.Object { return &SpaceConstraintList{} },
	)
	InternalSpaceConstraintStatus = builders.NewInternalResourceStatus(
		"spaceconstraints",
		"SpaceConstraintStatus",
		func() runtime.Object { return &SpaceConstraint{} },
		func() runtime.Object { return &SpaceConstraintList{} },
	)
	InternalSpaceInstance = builders.NewInternalResource(
		"spaceinstances",
		"SpaceInstance",
		func() runtime.Object { return &SpaceInstance{} },
		func() runtime.Object { return &SpaceInstanceList{} },
	)
	InternalSpaceInstanceStatus = builders.NewInternalResourceStatus(
		"spaceinstances",
		"SpaceInstanceStatus",
		func() runtime.Object { return &SpaceInstance{} },
		func() runtime.Object { return &SpaceInstanceList{} },
	)
	InternalSpaceTemplate = builders.NewInternalResource(
		"spacetemplates",
		"SpaceTemplate",
		func() runtime.Object { return &SpaceTemplate{} },
		func() runtime.Object { return &SpaceTemplateList{} },
	)
	InternalSpaceTemplateStatus = builders.NewInternalResourceStatus(
		"spacetemplates",
		"SpaceTemplateStatus",
		func() runtime.Object { return &SpaceTemplate{} },
		func() runtime.Object { return &SpaceTemplateList{} },
	)
	InternalSubjectAccessReview = builders.NewInternalResource(
		"subjectaccessreviews",
		"SubjectAccessReview",
		func() runtime.Object { return &SubjectAccessReview{} },
		func() runtime.Object { return &SubjectAccessReviewList{} },
	)
	InternalSubjectAccessReviewStatus = builders.NewInternalResourceStatus(
		"subjectaccessreviews",
		"SubjectAccessReviewStatus",
		func() runtime.Object { return &SubjectAccessReview{} },
		func() runtime.Object { return &SubjectAccessReviewList{} },
	)
	InternalTask = builders.NewInternalResource(
		"tasks",
		"Task",
		func() runtime.Object { return &Task{} },
		func() runtime.Object { return &TaskList{} },
	)
	InternalTaskStatus = builders.NewInternalResourceStatus(
		"tasks",
		"TaskStatus",
		func() runtime.Object { return &Task{} },
		func() runtime.Object { return &TaskList{} },
	)
	InternalTaskLogREST = builders.NewInternalSubresource(
		"tasks", "TaskLog", "log",
		func() runtime.Object { return &TaskLog{} },
	)
	NewTaskLogREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTaskLogRESTFunc(Factory)
	}
	NewTaskLogRESTFunc NewRESTFunc
	InternalTeam       = builders.NewInternalResource(
		"teams",
		"Team",
		func() runtime.Object { return &Team{} },
		func() runtime.Object { return &TeamList{} },
	)
	InternalTeamStatus = builders.NewInternalResourceStatus(
		"teams",
		"TeamStatus",
		func() runtime.Object { return &Team{} },
		func() runtime.Object { return &TeamList{} },
	)
	InternalTeamAccessKeysREST = builders.NewInternalSubresource(
		"teams", "TeamAccessKeys", "accesskeys",
		func() runtime.Object { return &TeamAccessKeys{} },
	)
	NewTeamAccessKeysREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTeamAccessKeysRESTFunc(Factory)
	}
	NewTeamAccessKeysRESTFunc NewRESTFunc
	InternalTeamClustersREST  = builders.NewInternalSubresource(
		"teams", "TeamClusters", "clusters",
		func() runtime.Object { return &TeamClusters{} },
	)
	NewTeamClustersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTeamClustersRESTFunc(Factory)
	}
	NewTeamClustersRESTFunc NewRESTFunc
	InternalUser            = builders.NewInternalResource(
		"users",
		"User",
		func() runtime.Object { return &User{} },
		func() runtime.Object { return &UserList{} },
	)
	InternalUserStatus = builders.NewInternalResourceStatus(
		"users",
		"UserStatus",
		func() runtime.Object { return &User{} },
		func() runtime.Object { return &UserList{} },
	)
	InternalUserAccessKeysREST = builders.NewInternalSubresource(
		"users", "UserAccessKeys", "accesskeys",
		func() runtime.Object { return &UserAccessKeys{} },
	)
	NewUserAccessKeysREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserAccessKeysRESTFunc(Factory)
	}
	NewUserAccessKeysRESTFunc NewRESTFunc
	InternalUserClustersREST  = builders.NewInternalSubresource(
		"users", "UserClusters", "clusters",
		func() runtime.Object { return &UserClusters{} },
	)
	NewUserClustersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserClustersRESTFunc(Factory)
	}
	NewUserClustersRESTFunc     NewRESTFunc
	InternalUserPermissionsREST = builders.NewInternalSubresource(
		"users", "UserPermissions", "permissions",
		func() runtime.Object { return &UserPermissions{} },
	)
	NewUserPermissionsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserPermissionsRESTFunc(Factory)
	}
	NewUserPermissionsRESTFunc NewRESTFunc
	InternalUserProfileREST    = builders.NewInternalSubresource(
		"users", "UserProfile", "profile",
		func() runtime.Object { return &UserProfile{} },
	)
	NewUserProfileREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserProfileRESTFunc(Factory)
	}
	NewUserProfileRESTFunc         NewRESTFunc
	InternalVirtualClusterInstance = builders.NewInternalResource(
		"virtualclusterinstances",
		"VirtualClusterInstance",
		func() runtime.Object { return &VirtualClusterInstance{} },
		func() runtime.Object { return &VirtualClusterInstanceList{} },
	)
	InternalVirtualClusterInstanceStatus = builders.NewInternalResourceStatus(
		"virtualclusterinstances",
		"VirtualClusterInstanceStatus",
		func() runtime.Object { return &VirtualClusterInstance{} },
		func() runtime.Object { return &VirtualClusterInstanceList{} },
	)
	InternalVirtualClusterInstanceKubeConfigREST = builders.NewInternalSubresource(
		"virtualclusterinstances", "VirtualClusterInstanceKubeConfig", "kubeconfig",
		func() runtime.Object { return &VirtualClusterInstanceKubeConfig{} },
	)
	NewVirtualClusterInstanceKubeConfigREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewVirtualClusterInstanceKubeConfigRESTFunc(Factory)
	}
	NewVirtualClusterInstanceKubeConfigRESTFunc NewRESTFunc
	InternalVirtualClusterInstanceLogREST       = builders.NewInternalSubresource(
		"virtualclusterinstances", "VirtualClusterInstanceLog", "log",
		func() runtime.Object { return &VirtualClusterInstanceLog{} },
	)
	NewVirtualClusterInstanceLogREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewVirtualClusterInstanceLogRESTFunc(Factory)
	}
	NewVirtualClusterInstanceLogRESTFunc                 NewRESTFunc
	InternalVirtualClusterInstanceWorkloadKubeConfigREST = builders.NewInternalSubresource(
		"virtualclusterinstances", "VirtualClusterInstanceWorkloadKubeConfig", "workloadkubeconfig",
		func() runtime.Object { return &VirtualClusterInstanceWorkloadKubeConfig{} },
	)
	NewVirtualClusterInstanceWorkloadKubeConfigREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewVirtualClusterInstanceWorkloadKubeConfigRESTFunc(Factory)
	}
	NewVirtualClusterInstanceWorkloadKubeConfigRESTFunc NewRESTFunc
	InternalVirtualClusterTemplate                      = builders.NewInternalResource(
		"virtualclustertemplates",
		"VirtualClusterTemplate",
		func() runtime.Object { return &VirtualClusterTemplate{} },
		func() runtime.Object { return &VirtualClusterTemplateList{} },
	)
	InternalVirtualClusterTemplateStatus = builders.NewInternalResourceStatus(
		"virtualclustertemplates",
		"VirtualClusterTemplateStatus",
		func() runtime.Object { return &VirtualClusterTemplate{} },
		func() runtime.Object { return &VirtualClusterTemplateList{} },
	)
	// Registered resources and subresources
	ApiVersion = builders.NewApiGroup("management.loft.sh").WithKinds(
		InternalAgentAuditEvent,
		InternalAgentAuditEventStatus,
		InternalAnnouncement,
		InternalAnnouncementStatus,
		InternalApp,
		InternalAppStatus,
		InternalCluster,
		InternalClusterStatus,
		InternalClusterAgentConfigREST,
		InternalClusterChartsREST,
		InternalClusterDomainREST,
		InternalClusterMemberAccessREST,
		InternalClusterMembersREST,
		InternalClusterResetREST,
		InternalClusterVirtualClusterDefaultsREST,
		InternalClusterAccess,
		InternalClusterAccessStatus,
		InternalClusterConnect,
		InternalClusterConnectStatus,
		InternalClusterRoleTemplate,
		InternalClusterRoleTemplateStatus,
		InternalConfig,
		InternalConfigStatus,
		InternalDevPodWorkspaceInstance,
		InternalDevPodWorkspaceInstanceStatus,
		InternalDevPodWorkspaceInstanceDeleteREST,
		InternalDevPodWorkspaceInstanceGetStatusREST,
		InternalDevPodWorkspaceInstanceSshREST,
		InternalDevPodWorkspaceInstanceStopREST,
		InternalDevPodWorkspaceInstanceUpREST,
		InternalDevPodWorkspaceTemplate,
		InternalDevPodWorkspaceTemplateStatus,
		InternalDirectClusterEndpointToken,
		InternalDirectClusterEndpointTokenStatus,
		InternalEvent,
		InternalEventStatus,
		InternalFeature,
		InternalFeatureStatus,
		InternalIngressAuthToken,
		InternalIngressAuthTokenStatus,
		InternalKiosk,
		InternalKioskStatus,
		InternalLicense,
		InternalLicenseStatus,
		InternalLicenseRequestREST,
		InternalLicenseToken,
		InternalLicenseTokenStatus,
		InternalLoftUpgrade,
		InternalLoftUpgradeStatus,
		InternalOwnedAccessKey,
		InternalOwnedAccessKeyStatus,
		InternalPolicyViolation,
		InternalPolicyViolationStatus,
		InternalProject,
		InternalProjectStatus,
		InternalProjectChartInfoREST,
		InternalProjectChartsREST,
		InternalProjectClustersREST,
		InternalProjectImportSpaceREST,
		InternalProjectImportVirtualClusterREST,
		InternalProjectMembersREST,
		InternalProjectMigrateSpaceInstanceREST,
		InternalProjectMigrateVirtualClusterInstanceREST,
		InternalProjectTemplatesREST,
		InternalProjectSecret,
		InternalProjectSecretStatus,
		InternalRedirectToken,
		InternalRedirectTokenStatus,
		InternalResetAccessKey,
		InternalResetAccessKeyStatus,
		InternalRunner,
		InternalRunnerStatus,
		InternalRunnerAccessKeyREST,
		InternalRunnerConfigREST,
		InternalSelf,
		InternalSelfStatus,
		InternalSelfSubjectAccessReview,
		InternalSelfSubjectAccessReviewStatus,
		InternalSharedSecret,
		InternalSharedSecretStatus,
		InternalSpaceConstraint,
		InternalSpaceConstraintStatus,
		InternalSpaceInstance,
		InternalSpaceInstanceStatus,
		InternalSpaceTemplate,
		InternalSpaceTemplateStatus,
		InternalSubjectAccessReview,
		InternalSubjectAccessReviewStatus,
		InternalTask,
		InternalTaskStatus,
		InternalTaskLogREST,
		InternalTeam,
		InternalTeamStatus,
		InternalTeamAccessKeysREST,
		InternalTeamClustersREST,
		InternalUser,
		InternalUserStatus,
		InternalUserAccessKeysREST,
		InternalUserClustersREST,
		InternalUserPermissionsREST,
		InternalUserProfileREST,
		InternalVirtualClusterInstance,
		InternalVirtualClusterInstanceStatus,
		InternalVirtualClusterInstanceKubeConfigREST,
		InternalVirtualClusterInstanceLogREST,
		InternalVirtualClusterInstanceWorkloadKubeConfigREST,
		InternalVirtualClusterTemplate,
		InternalVirtualClusterTemplateStatus,
	)

	// Required by code generated by go2idl
	AddToScheme = (&runtime.SchemeBuilder{
		ApiVersion.SchemeBuilder.AddToScheme,
		RegisterDefaults,
	}).AddToScheme
	SchemeBuilder      = ApiVersion.SchemeBuilder
	localSchemeBuilder = &SchemeBuilder
	SchemeGroupVersion = ApiVersion.GroupVersion
)

// Required by code generated by go2idl
// Kind takes an unqualified kind and returns a Group qualified GroupKind
func Kind(kind string) schema.GroupKind {
	return SchemeGroupVersion.WithKind(kind).GroupKind()
}

// Required by code generated by go2idl
// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource {
	return SchemeGroupVersion.WithResource(resource).GroupResource()
}

type AccessKeyType string
type Level string
type RequestTarget string
type Stage string

type AgentAnalyticsSpec struct {
	AnalyticsEndpoint string
}

type AgentAuditConfig struct {
	Enabled              bool
	DisableAgentSyncBack bool
	Level                int
	Policy               AuditPolicy
	Path                 string
	MaxAge               int
	MaxBackups           int
	MaxSize              int
	Compress             bool
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AgentAuditEvent struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   AgentAuditEventSpec
	Status AgentAuditEventStatus
}

type AgentAuditEventSpec struct {
	Events []*auditv1.Event
}

type AgentAuditEventStatus struct {
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Announcement struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   AnnouncementSpec
	Status AnnouncementStatus
}

type AnnouncementSpec struct {
}

type AnnouncementStatus struct {
	Announcement pkglicenseapi.Announcement
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type App struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   AppSpec
	Status AppStatus
}

type AppSpec struct {
	storagev1.AppSpec
}

type AppStatus struct {
	storagev1.AppStatus
}

type Apps struct {
	NoDefault      bool
	Repositories   []storagev1.HelmChartRepository
	PredefinedApps []PredefinedApp
}

type Audit struct {
	Enabled              bool
	DisableAgentSyncBack bool
	Level                int
	Policy               AuditPolicy
	DataStoreEndpoint    string
	DataStoreMaxAge      *int
	Path                 string
	MaxAge               int
	MaxBackups           int
	MaxSize              int
	Compress             bool
}

type AuditPolicy struct {
	Rules      []AuditPolicyRule
	OmitStages []auditv1.Stage
}

type AuditPolicyRule struct {
	Level           auditv1.Level
	Users           []string
	UserGroups      []string
	Verbs           []string
	Resources       []GroupResources
	Namespaces      []string
	NonResourceURLs []string
	OmitStages      []auditv1.Stage
	RequestTargets  []auditv1.RequestTarget
	Clusters        []string
}

type Authentication struct {
	Connector
	Rancher                  *AuthenticationRancher
	Password                 *AuthenticationPassword
	Connectors               []ConnectorWithName
	DisableTeamCreation      bool
	AccessKeyMaxTTLSeconds   int64
	LoginAccessKeyTTLSeconds *int64
	CustomHttpHeaders        map[string]string
}

type AuthenticationClusterAccountTemplates struct {
	ClusterAccountTemplates      []storagev1.UserClusterAccountTemplate
	GroupClusterAccountTemplates []AuthenticationGroupClusterAccountTemplate
}

type AuthenticationGithub struct {
	ClientID     string
	ClientSecret string
	RedirectURI  string
	Orgs         []AuthenticationGithubOrg
	HostName     string
	RootCA       string
	AuthenticationClusterAccountTemplates
}

type AuthenticationGithubOrg struct {
	Name  string
	Teams []string
}

type AuthenticationGitlab struct {
	ClientID     string
	ClientSecret string
	RedirectURI  string
	BaseURL      string
	Groups       []string
	AuthenticationClusterAccountTemplates
}

type AuthenticationGoogle struct {
	ClientID               string
	ClientSecret           string
	RedirectURI            string
	Scopes                 []string
	HostedDomains          []string
	Groups                 []string
	ServiceAccountFilePath string
	AdminEmail             string
	AuthenticationClusterAccountTemplates
}

type AuthenticationGroupClusterAccountTemplate struct {
	Group                   string
	ClusterAccountTemplates []storagev1.UserClusterAccountTemplate
}

type AuthenticationMicrosoft struct {
	ClientID             string
	ClientSecret         string
	RedirectURI          string
	Tenant               string
	Groups               []string
	OnlySecurityGroups   bool
	UseGroupsAsWhitelist bool
	AuthenticationClusterAccountTemplates
}

type AuthenticationOIDC struct {
	IssuerURL              string
	ClientID               string
	ClientSecret           string
	RedirectURI            string
	PostLogoutRedirectURI  string
	CAFile                 string
	InsecureCA             bool
	PreferredUsernameClaim string
	LoftUsernameClaim      string
	UsernameClaim          string
	EmailClaim             string
	UsernamePrefix         string
	GroupsClaim            string
	Groups                 []string
	Scopes                 []string
	GetUserInfo            bool
	GroupsPrefix           string
	Type                   string
	AuthenticationClusterAccountTemplates
}

type AuthenticationPassword struct {
	Disabled bool
}

type AuthenticationRancher struct {
	Host        string
	BearerToken string
	Insecure    bool
}

type AuthenticationSAML struct {
	RedirectURI                     string
	SSOURL                          string
	CAData                          []byte
	UsernameAttr                    string
	EmailAttr                       string
	GroupsAttr                      string
	CA                              string
	InsecureSkipSignatureValidation bool
	EntityIssuer                    string
	SSOIssuer                       string
	GroupsDelim                     string
	AllowedGroups                   []string
	FilterGroups                    bool
	NameIDPolicyFormat              string
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Cluster struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ClusterSpec
	Status ClusterStatus
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterAccess struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ClusterAccessSpec
	Status ClusterAccessStatus
}

type ClusterAccessSpec struct {
	storagev1.ClusterAccessSpec
}

type ClusterAccessStatus struct {
	storagev1.ClusterAccessStatus
	Clusters        []*clusterv1.EntityInfo
	Users           []*clusterv1.UserOrTeam
	Teams           []*clusterv1.EntityInfo
	SpaceConstraint *clusterv1.EntityInfo
}

type ClusterAccounts struct {
	Accounts []string
	Cluster  storagev1.Cluster
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterAgentConfig struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Cluster              string
	Audit                *AgentAuditConfig
	DefaultImageRegistry string
	TokenCaCert          []byte
	LoftHost             string
	AnalyticsSpec        AgentAnalyticsSpec
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterCharts struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Charts []storagev1.HelmChart
	Busy   bool
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterConnect struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ClusterConnectSpec
	Status ClusterConnectStatus
}

type ClusterConnectSpec struct {
	Config          string
	AdminUser       string
	ClusterTemplate Cluster
}

type ClusterConnectStatus struct {
	Failed  bool
	Reason  string
	Message string
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterDomain struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Target string
	Domain string
}

type ClusterMember struct {
	Info clusterv1.EntityInfo
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterMemberAccess struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Teams []ClusterMember
	Users []ClusterMember
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterMembers struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Teams []ClusterMember
	Users []ClusterMember
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterReset struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Agent bool
	RBAC  bool
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterRoleTemplate struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ClusterRoleTemplateSpec
	Status ClusterRoleTemplateStatus
}

type ClusterRoleTemplateSpec struct {
	storagev1.ClusterRoleTemplateSpec
}

type ClusterRoleTemplateStatus struct {
	storagev1.ClusterRoleTemplateStatus
	Clusters []*clusterv1.EntityInfo
}

type ClusterSpec struct {
	storagev1.ClusterSpec
}

type ClusterStatus struct {
	storagev1.ClusterStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterVirtualClusterDefaults struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	DefaultTemplate *storagev1.VirtualClusterTemplate
	LatestVersion   string
	Values          string
	Warning         string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Config struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ConfigSpec
	Status ConfigStatus
}

type ConfigSpec struct {
	Raw []byte
}

type ConfigStatus struct {
	Authentication   Authentication
	OIDC             *OIDC
	Apps             *Apps
	Audit            *Audit
	LoftHost         string
	DevPodSubDomain  string
	UISettings       *uiv1.UISettingsConfig
	VaultIntegration *storagev1.VaultIntegrationSpec
}

type Connector struct {
	OIDC      *AuthenticationOIDC
	Github    *AuthenticationGithub
	Gitlab    *AuthenticationGitlab
	Google    *AuthenticationGoogle
	Microsoft *AuthenticationMicrosoft
	SAML      *AuthenticationSAML
}

type ConnectorWithName struct {
	ID          string
	DisplayName string
	Connector
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstance struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   DevPodWorkspaceInstanceSpec
	Status DevPodWorkspaceInstanceStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceDelete struct {
	metav1.TypeMeta
	metav1.ObjectMeta
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceGetStatus struct {
	metav1.TypeMeta
	metav1.ObjectMeta
}

type DevPodWorkspaceInstanceSpec struct {
	storagev1.DevPodWorkspaceInstanceSpec
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceSsh struct {
	metav1.TypeMeta
	metav1.ObjectMeta
}

type DevPodWorkspaceInstanceStatus struct {
	storagev1.DevPodWorkspaceInstanceStatus
	SleepModeConfig *clusterv1.SleepModeConfig
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceStop struct {
	metav1.TypeMeta
	metav1.ObjectMeta
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceUp struct {
	metav1.TypeMeta
	metav1.ObjectMeta
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceTemplate struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   DevPodWorkspaceTemplateSpec
	Status DevPodWorkspaceTemplateStatus
}

type DevPodWorkspaceTemplateSpec struct {
	storagev1.DevPodWorkspaceTemplateSpec
}

type DevPodWorkspaceTemplateStatus struct {
	storagev1.DevPodWorkspaceTemplateStatus
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DirectClusterEndpointToken struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   DirectClusterEndpointTokenSpec
	Status DirectClusterEndpointTokenStatus
}

type DirectClusterEndpointTokenSpec struct {
	TTL   int64
	Scope *storagev1.AccessKeyScope
}

type DirectClusterEndpointTokenStatus struct {
	Token string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Event struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   EventSpec
	Status EventStatus
}

type EventSpec struct {
}

type EventStatus struct {
	auditv1.Event
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Feature struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   FeatureSpec
	Status FeatureStatus
}

type FeatureSpec struct {
}

type FeatureStatus struct {
	pkglicenseapi.Feature
	Internal bool
	Used     bool
}

type GroupResources struct {
	Group         string
	Resources     []string
	ResourceNames []string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type IngressAuthToken struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   IngressAuthTokenSpec
	Status IngressAuthTokenStatus
}

type IngressAuthTokenSpec struct {
	Host      string
	Signature string
}

type IngressAuthTokenStatus struct {
	Token string
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Kiosk struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   KioskSpec
	Status KioskStatus
}

type KioskSpec struct {
	JsPolicy              policyv1beta1.JsPolicy
	JsPolicyBundle        policyv1beta1.JsPolicyBundle
	JsPolicyViolations    policyv1beta1.JsPolicyViolations
	HelmRelease           clusterv1.HelmRelease
	SleepModeConfig       clusterv1.SleepModeConfig
	Space                 clusterv1.Space
	VirtualCluster        clusterv1.VirtualCluster
	LocalClusterAccess    clusterv1.LocalClusterAccess
	ClusterQuota          clusterv1.ClusterQuota
	ChartInfo             clusterv1.ChartInfo
	StorageClusterAccess  agentstoragev1.LocalClusterAccess
	StorageClusterQuota   agentstoragev1.ClusterQuota
	StorageVirtualCluster agentstoragev1.VirtualCluster
	LocalUser             agentstoragev1.LocalUser
	LocalTeam             agentstoragev1.LocalTeam
	UISettings            uiv1.UISettings
	License               License
}

type KioskStatus struct {
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type License struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   LicenseSpec
	Status LicenseStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseRequest struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   LicenseRequestSpec
	Status LicenseRequestStatus
}

type LicenseRequestSpec struct {
	URL   string
	Input pkglicenseapi.GenericRequestInput
}

type LicenseRequestStatus struct {
	Output *pkglicenseapi.GenericRequestOutput
}

type LicenseSpec struct {
}

type LicenseStatus struct {
	License       *pkglicenseapi.License
	ResourceUsage map[string]pkglicenseapi.ResourceCount
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseToken struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   LicenseTokenSpec
	Status LicenseTokenStatus
}

type LicenseTokenSpec struct {
	URL     string
	Payload string
}

type LicenseTokenStatus struct {
	Token *pkglicenseapi.InstanceTokenAuth
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LoftUpgrade struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   LoftUpgradeSpec
	Status LoftUpgradeStatus
}

type LoftUpgradeSpec struct {
	Namespace string
	Release   string
	Version   string
}

type LoftUpgradeStatus struct {
}

type OIDC struct {
	Enabled          bool
	WildcardRedirect bool
	Clients          []OIDCClient
}

type OIDCClient struct {
	Name         string
	ClientID     string
	ClientSecret string
	RedirectURIs []string
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type OwnedAccessKey struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   OwnedAccessKeySpec
	Status OwnedAccessKeyStatus
}

type OwnedAccessKeySpec struct {
	storagev1.AccessKeySpec
}

type OwnedAccessKeyStatus struct {
	storagev1.AccessKeyStatus
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type PolicyViolation struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   PolicyViolationSpec
	Status PolicyViolationStatus
}

type PolicyViolationSpec struct {
}

type PolicyViolationStatus struct {
	Policy    string
	Cluster   string
	User      *clusterv1.EntityInfo
	Violation policyv1beta1.PolicyViolation
}

type PredefinedApp struct {
	Chart          string
	InitialVersion string
	InitialValues  string
	Clusters       []string
	Title          string
	IconURL        string
	ReadmeURL      string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Project struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ProjectSpec
	Status ProjectStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectChartInfo struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ProjectChartInfoSpec
	Status ProjectChartInfoStatus
}

type ProjectChartInfoSpec struct {
	clusterv1.ChartInfoSpec
}

type ProjectChartInfoStatus struct {
	clusterv1.ChartInfoStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectCharts struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Charts []storagev1.HelmChart
	Busy   bool
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectClusters struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Clusters []Cluster
	Runners  []Runner
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectImportSpace struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	SourceSpace ProjectImportSpaceSource
}

type ProjectImportSpaceSource struct {
	Name       string
	Cluster    string
	ImportName string
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectImportVirtualCluster struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	SourceVirtualCluster ProjectImportVirtualClusterSource
	UpgradeToPro         bool
}

type ProjectImportVirtualClusterSource struct {
	Name       string
	Namespace  string
	Cluster    string
	ImportName string
}

type ProjectMember struct {
	Info clusterv1.EntityInfo
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectMembers struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Teams []ProjectMember
	Users []ProjectMember
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectMigrateSpaceInstance struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	SourceSpaceInstance ProjectMigrateSpaceInstanceSource
}

type ProjectMigrateSpaceInstanceSource struct {
	Name      string
	Namespace string
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectMigrateVirtualClusterInstance struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	SourceVirtualClusterInstance ProjectMigrateVirtualClusterInstanceSource
}

type ProjectMigrateVirtualClusterInstanceSource struct {
	Name      string
	Namespace string
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectSecret struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ProjectSecretSpec
	Status ProjectSecretStatus
}

type ProjectSecretSpec struct {
	DisplayName string
	Description string
	Owner       *storagev1.UserOrTeam
	Data        map[string][]byte
	Access      []storagev1.Access
}

type ProjectSecretStatus struct {
	Conditions agentstoragev1.Conditions
}

type ProjectSpec struct {
	storagev1.ProjectSpec
}

type ProjectStatus struct {
	storagev1.ProjectStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectTemplates struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	DefaultVirtualClusterTemplate  string
	VirtualClusterTemplates        []VirtualClusterTemplate
	DefaultSpaceTemplate           string
	SpaceTemplates                 []SpaceTemplate
	DefaultDevPodWorkspaceTemplate string
	DevPodWorkspaceTemplates       []DevPodWorkspaceTemplate
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type RedirectToken struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   RedirectTokenSpec
	Status RedirectTokenStatus
}

type RedirectTokenSpec struct {
	Token string
}

type RedirectTokenStatus struct {
	RedirectURL string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ResetAccessKey struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   ResetAccessKeySpec
	Status ResetAccessKeyStatus
}

type ResetAccessKeySpec struct {
	storagev1.AccessKeySpec
}

type ResetAccessKeyStatus struct {
	storagev1.AccessKeyStatus
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Runner struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   RunnerSpec
	Status RunnerStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type RunnerAccessKey struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	AccessKey string
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type RunnerConfig struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	TokenCaCert []byte
}

type RunnerSpec struct {
	storagev1.RunnerSpec
}

type RunnerStatus struct {
	storagev1.RunnerStatus
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Self struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   SelfSpec
	Status SelfStatus
}

type SelfSpec struct {
	AccessKey string
}

type SelfStatus struct {
	User           *UserInfo
	Team           *clusterv1.EntityInfo
	AccessKey      string
	AccessKeyScope *storagev1.AccessKeyScope
	AccessKeyType  storagev1.AccessKeyType
	Subject        string
	UID            string
	Groups         []string
	ChatAuthToken  string
	InstanceID     string
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SelfSubjectAccessReview struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   SelfSubjectAccessReviewSpec
	Status SelfSubjectAccessReviewStatus
}

type SelfSubjectAccessReviewSpec struct {
	authorizationv1.SelfSubjectAccessReviewSpec
}

type SelfSubjectAccessReviewStatus struct {
	authorizationv1.SubjectAccessReviewStatus
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SharedSecret struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   SharedSecretSpec
	Status SharedSecretStatus
}

type SharedSecretSpec struct {
	storagev1.SharedSecretSpec
}

type SharedSecretStatus struct {
	storagev1.SharedSecretStatus
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SpaceConstraint struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   SpaceConstraintSpec
	Status SpaceConstraintStatus
}

type SpaceConstraintSpec struct {
	storagev1.SpaceConstraintSpec
}

type SpaceConstraintStatus struct {
	storagev1.SpaceConstraintStatus
	ClusterRole *clusterv1.EntityInfo
	Clusters    []*clusterv1.EntityInfo
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SpaceInstance struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   SpaceInstanceSpec
	Status SpaceInstanceStatus
}

type SpaceInstanceSpec struct {
	storagev1.SpaceInstanceSpec
}

type SpaceInstanceStatus struct {
	storagev1.SpaceInstanceStatus
	SleepModeConfig *clusterv1.SleepModeConfig
	CanUse          bool
	CanUpdate       bool
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SpaceTemplate struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   SpaceTemplateSpec
	Status SpaceTemplateStatus
}

type SpaceTemplateSpec struct {
	storagev1.SpaceTemplateSpec
}

type SpaceTemplateStatus struct {
	storagev1.SpaceTemplateStatus
	Apps []*clusterv1.EntityInfo
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SubjectAccessReview struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   SubjectAccessReviewSpec
	Status SubjectAccessReviewStatus
}

type SubjectAccessReviewSpec struct {
	authorizationv1.SubjectAccessReviewSpec
}

type SubjectAccessReviewStatus struct {
	authorizationv1.SubjectAccessReviewStatus
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Task struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   TaskSpec
	Status TaskStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TaskLog struct {
	metav1.TypeMeta
	metav1.ObjectMeta
}

type TaskSpec struct {
	storagev1.TaskSpec
}

type TaskStatus struct {
	storagev1.TaskStatus
	Owner   *clusterv1.UserOrTeam
	Cluster *clusterv1.EntityInfo
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Team struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   TeamSpec
	Status TeamStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamAccessKeys struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	AccessKeys []OwnedAccessKey
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamClusters struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Clusters []ClusterAccounts
}

type TeamSpec struct {
	storagev1.TeamSpec
}

type TeamStatus struct {
	storagev1.TeamStatus
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type User struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   UserSpec
	Status UserStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserAccessKeys struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	AccessKeys []OwnedAccessKey
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserClusters struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Clusters []ClusterAccounts
}

type UserInfo struct {
	clusterv1.EntityInfo
	Teams []*clusterv1.EntityInfo
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserPermissions struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	ClusterRoles   []UserPermissionsRole
	NamespaceRoles []UserPermissionsRole
}

type UserPermissionsRole struct {
	ClusterRole string
	Role        string
	Namespace   string
	Rules       []rbacv1.PolicyRule
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserProfile struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	DisplayName     string
	Username        string
	Password        string
	CurrentPassword string
	Email           string
	Icon            *string
	Custom          string
}

type UserSpec struct {
	storagev1.UserSpec
}

type UserStatus struct {
	storagev1.UserStatus
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterInstance struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   VirtualClusterInstanceSpec
	Status VirtualClusterInstanceStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterInstanceKubeConfig struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   VirtualClusterInstanceKubeConfigSpec
	Status VirtualClusterInstanceKubeConfigStatus
}

type VirtualClusterInstanceKubeConfigSpec struct {
	CertificateTTL *int32
}

type VirtualClusterInstanceKubeConfigStatus struct {
	KubeConfig string
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterInstanceLog struct {
	metav1.TypeMeta
	metav1.ObjectMeta
}

type VirtualClusterInstanceSpec struct {
	storagev1.VirtualClusterInstanceSpec
}

type VirtualClusterInstanceStatus struct {
	storagev1.VirtualClusterInstanceStatus
	SleepModeConfig *clusterv1.SleepModeConfig
	CanUse          bool
	CanUpdate       bool
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterInstanceWorkloadKubeConfig struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	KubeConfig string
	Token      string
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterTemplate struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   VirtualClusterTemplateSpec
	Status VirtualClusterTemplateStatus
}

type VirtualClusterTemplateSpec struct {
	storagev1.VirtualClusterTemplateSpec
}

type VirtualClusterTemplateStatus struct {
	storagev1.VirtualClusterTemplateStatus
	Apps []*clusterv1.EntityInfo
}

// AgentAuditEvent Functions and Structs
//
// +k8s:deepcopy-gen=false
type AgentAuditEventStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type AgentAuditEventStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AgentAuditEventList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []AgentAuditEvent
}

func (AgentAuditEvent) NewStatus() interface{} {
	return AgentAuditEventStatus{}
}

func (pc *AgentAuditEvent) GetStatus() interface{} {
	return pc.Status
}

func (pc *AgentAuditEvent) SetStatus(s interface{}) {
	pc.Status = s.(AgentAuditEventStatus)
}

func (pc *AgentAuditEvent) GetSpec() interface{} {
	return pc.Spec
}

func (pc *AgentAuditEvent) SetSpec(s interface{}) {
	pc.Spec = s.(AgentAuditEventSpec)
}

func (pc *AgentAuditEvent) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *AgentAuditEvent) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc AgentAuditEvent) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store AgentAuditEvent.
// +k8s:deepcopy-gen=false
type AgentAuditEventRegistry interface {
	ListAgentAuditEvents(ctx context.Context, options *internalversion.ListOptions) (*AgentAuditEventList, error)
	GetAgentAuditEvent(ctx context.Context, id string, options *metav1.GetOptions) (*AgentAuditEvent, error)
	CreateAgentAuditEvent(ctx context.Context, id *AgentAuditEvent) (*AgentAuditEvent, error)
	UpdateAgentAuditEvent(ctx context.Context, id *AgentAuditEvent) (*AgentAuditEvent, error)
	DeleteAgentAuditEvent(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewAgentAuditEventRegistry(sp builders.StandardStorageProvider) AgentAuditEventRegistry {
	return &storageAgentAuditEvent{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageAgentAuditEvent struct {
	builders.StandardStorageProvider
}

func (s *storageAgentAuditEvent) ListAgentAuditEvents(ctx context.Context, options *internalversion.ListOptions) (*AgentAuditEventList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*AgentAuditEventList), err
}

func (s *storageAgentAuditEvent) GetAgentAuditEvent(ctx context.Context, id string, options *metav1.GetOptions) (*AgentAuditEvent, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*AgentAuditEvent), nil
}

func (s *storageAgentAuditEvent) CreateAgentAuditEvent(ctx context.Context, object *AgentAuditEvent) (*AgentAuditEvent, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*AgentAuditEvent), nil
}

func (s *storageAgentAuditEvent) UpdateAgentAuditEvent(ctx context.Context, object *AgentAuditEvent) (*AgentAuditEvent, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*AgentAuditEvent), nil
}

func (s *storageAgentAuditEvent) DeleteAgentAuditEvent(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Announcement Functions and Structs
//
// +k8s:deepcopy-gen=false
type AnnouncementStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type AnnouncementStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AnnouncementList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Announcement
}

func (Announcement) NewStatus() interface{} {
	return AnnouncementStatus{}
}

func (pc *Announcement) GetStatus() interface{} {
	return pc.Status
}

func (pc *Announcement) SetStatus(s interface{}) {
	pc.Status = s.(AnnouncementStatus)
}

func (pc *Announcement) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Announcement) SetSpec(s interface{}) {
	pc.Spec = s.(AnnouncementSpec)
}

func (pc *Announcement) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Announcement) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Announcement) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Announcement.
// +k8s:deepcopy-gen=false
type AnnouncementRegistry interface {
	ListAnnouncements(ctx context.Context, options *internalversion.ListOptions) (*AnnouncementList, error)
	GetAnnouncement(ctx context.Context, id string, options *metav1.GetOptions) (*Announcement, error)
	CreateAnnouncement(ctx context.Context, id *Announcement) (*Announcement, error)
	UpdateAnnouncement(ctx context.Context, id *Announcement) (*Announcement, error)
	DeleteAnnouncement(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewAnnouncementRegistry(sp builders.StandardStorageProvider) AnnouncementRegistry {
	return &storageAnnouncement{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageAnnouncement struct {
	builders.StandardStorageProvider
}

func (s *storageAnnouncement) ListAnnouncements(ctx context.Context, options *internalversion.ListOptions) (*AnnouncementList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*AnnouncementList), err
}

func (s *storageAnnouncement) GetAnnouncement(ctx context.Context, id string, options *metav1.GetOptions) (*Announcement, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Announcement), nil
}

func (s *storageAnnouncement) CreateAnnouncement(ctx context.Context, object *Announcement) (*Announcement, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Announcement), nil
}

func (s *storageAnnouncement) UpdateAnnouncement(ctx context.Context, object *Announcement) (*Announcement, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Announcement), nil
}

func (s *storageAnnouncement) DeleteAnnouncement(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// App Functions and Structs
//
// +k8s:deepcopy-gen=false
type AppStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type AppStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AppList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []App
}

func (App) NewStatus() interface{} {
	return AppStatus{}
}

func (pc *App) GetStatus() interface{} {
	return pc.Status
}

func (pc *App) SetStatus(s interface{}) {
	pc.Status = s.(AppStatus)
}

func (pc *App) GetSpec() interface{} {
	return pc.Spec
}

func (pc *App) SetSpec(s interface{}) {
	pc.Spec = s.(AppSpec)
}

func (pc *App) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *App) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc App) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store App.
// +k8s:deepcopy-gen=false
type AppRegistry interface {
	ListApps(ctx context.Context, options *internalversion.ListOptions) (*AppList, error)
	GetApp(ctx context.Context, id string, options *metav1.GetOptions) (*App, error)
	CreateApp(ctx context.Context, id *App) (*App, error)
	UpdateApp(ctx context.Context, id *App) (*App, error)
	DeleteApp(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewAppRegistry(sp builders.StandardStorageProvider) AppRegistry {
	return &storageApp{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageApp struct {
	builders.StandardStorageProvider
}

func (s *storageApp) ListApps(ctx context.Context, options *internalversion.ListOptions) (*AppList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*AppList), err
}

func (s *storageApp) GetApp(ctx context.Context, id string, options *metav1.GetOptions) (*App, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*App), nil
}

func (s *storageApp) CreateApp(ctx context.Context, object *App) (*App, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*App), nil
}

func (s *storageApp) UpdateApp(ctx context.Context, object *App) (*App, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*App), nil
}

func (s *storageApp) DeleteApp(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Cluster Functions and Structs
//
// +k8s:deepcopy-gen=false
type ClusterStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ClusterStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Cluster
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterAgentConfigList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterAgentConfig
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterChartsList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterCharts
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterDomainList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterDomain
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterMemberAccessList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterMemberAccess
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterMembersList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterMembers
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterResetList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterReset
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterVirtualClusterDefaultsList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterVirtualClusterDefaults
}

func (Cluster) NewStatus() interface{} {
	return ClusterStatus{}
}

func (pc *Cluster) GetStatus() interface{} {
	return pc.Status
}

func (pc *Cluster) SetStatus(s interface{}) {
	pc.Status = s.(ClusterStatus)
}

func (pc *Cluster) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Cluster) SetSpec(s interface{}) {
	pc.Spec = s.(ClusterSpec)
}

func (pc *Cluster) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Cluster) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Cluster) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Cluster.
// +k8s:deepcopy-gen=false
type ClusterRegistry interface {
	ListClusters(ctx context.Context, options *internalversion.ListOptions) (*ClusterList, error)
	GetCluster(ctx context.Context, id string, options *metav1.GetOptions) (*Cluster, error)
	CreateCluster(ctx context.Context, id *Cluster) (*Cluster, error)
	UpdateCluster(ctx context.Context, id *Cluster) (*Cluster, error)
	DeleteCluster(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewClusterRegistry(sp builders.StandardStorageProvider) ClusterRegistry {
	return &storageCluster{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageCluster struct {
	builders.StandardStorageProvider
}

func (s *storageCluster) ListClusters(ctx context.Context, options *internalversion.ListOptions) (*ClusterList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterList), err
}

func (s *storageCluster) GetCluster(ctx context.Context, id string, options *metav1.GetOptions) (*Cluster, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Cluster), nil
}

func (s *storageCluster) CreateCluster(ctx context.Context, object *Cluster) (*Cluster, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Cluster), nil
}

func (s *storageCluster) UpdateCluster(ctx context.Context, object *Cluster) (*Cluster, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Cluster), nil
}

func (s *storageCluster) DeleteCluster(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// ClusterAccess Functions and Structs
//
// +k8s:deepcopy-gen=false
type ClusterAccessStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ClusterAccessStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterAccessList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterAccess
}

func (ClusterAccess) NewStatus() interface{} {
	return ClusterAccessStatus{}
}

func (pc *ClusterAccess) GetStatus() interface{} {
	return pc.Status
}

func (pc *ClusterAccess) SetStatus(s interface{}) {
	pc.Status = s.(ClusterAccessStatus)
}

func (pc *ClusterAccess) GetSpec() interface{} {
	return pc.Spec
}

func (pc *ClusterAccess) SetSpec(s interface{}) {
	pc.Spec = s.(ClusterAccessSpec)
}

func (pc *ClusterAccess) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *ClusterAccess) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc ClusterAccess) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store ClusterAccess.
// +k8s:deepcopy-gen=false
type ClusterAccessRegistry interface {
	ListClusterAccesss(ctx context.Context, options *internalversion.ListOptions) (*ClusterAccessList, error)
	GetClusterAccess(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterAccess, error)
	CreateClusterAccess(ctx context.Context, id *ClusterAccess) (*ClusterAccess, error)
	UpdateClusterAccess(ctx context.Context, id *ClusterAccess) (*ClusterAccess, error)
	DeleteClusterAccess(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewClusterAccessRegistry(sp builders.StandardStorageProvider) ClusterAccessRegistry {
	return &storageClusterAccess{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageClusterAccess struct {
	builders.StandardStorageProvider
}

func (s *storageClusterAccess) ListClusterAccesss(ctx context.Context, options *internalversion.ListOptions) (*ClusterAccessList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterAccessList), err
}

func (s *storageClusterAccess) GetClusterAccess(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterAccess, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterAccess), nil
}

func (s *storageClusterAccess) CreateClusterAccess(ctx context.Context, object *ClusterAccess) (*ClusterAccess, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterAccess), nil
}

func (s *storageClusterAccess) UpdateClusterAccess(ctx context.Context, object *ClusterAccess) (*ClusterAccess, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterAccess), nil
}

func (s *storageClusterAccess) DeleteClusterAccess(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// ClusterConnect Functions and Structs
//
// +k8s:deepcopy-gen=false
type ClusterConnectStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ClusterConnectStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterConnectList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterConnect
}

func (ClusterConnect) NewStatus() interface{} {
	return ClusterConnectStatus{}
}

func (pc *ClusterConnect) GetStatus() interface{} {
	return pc.Status
}

func (pc *ClusterConnect) SetStatus(s interface{}) {
	pc.Status = s.(ClusterConnectStatus)
}

func (pc *ClusterConnect) GetSpec() interface{} {
	return pc.Spec
}

func (pc *ClusterConnect) SetSpec(s interface{}) {
	pc.Spec = s.(ClusterConnectSpec)
}

func (pc *ClusterConnect) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *ClusterConnect) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc ClusterConnect) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store ClusterConnect.
// +k8s:deepcopy-gen=false
type ClusterConnectRegistry interface {
	ListClusterConnects(ctx context.Context, options *internalversion.ListOptions) (*ClusterConnectList, error)
	GetClusterConnect(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterConnect, error)
	CreateClusterConnect(ctx context.Context, id *ClusterConnect) (*ClusterConnect, error)
	UpdateClusterConnect(ctx context.Context, id *ClusterConnect) (*ClusterConnect, error)
	DeleteClusterConnect(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewClusterConnectRegistry(sp builders.StandardStorageProvider) ClusterConnectRegistry {
	return &storageClusterConnect{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageClusterConnect struct {
	builders.StandardStorageProvider
}

func (s *storageClusterConnect) ListClusterConnects(ctx context.Context, options *internalversion.ListOptions) (*ClusterConnectList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterConnectList), err
}

func (s *storageClusterConnect) GetClusterConnect(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterConnect, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterConnect), nil
}

func (s *storageClusterConnect) CreateClusterConnect(ctx context.Context, object *ClusterConnect) (*ClusterConnect, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterConnect), nil
}

func (s *storageClusterConnect) UpdateClusterConnect(ctx context.Context, object *ClusterConnect) (*ClusterConnect, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterConnect), nil
}

func (s *storageClusterConnect) DeleteClusterConnect(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// ClusterRoleTemplate Functions and Structs
//
// +k8s:deepcopy-gen=false
type ClusterRoleTemplateStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ClusterRoleTemplateStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterRoleTemplateList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ClusterRoleTemplate
}

func (ClusterRoleTemplate) NewStatus() interface{} {
	return ClusterRoleTemplateStatus{}
}

func (pc *ClusterRoleTemplate) GetStatus() interface{} {
	return pc.Status
}

func (pc *ClusterRoleTemplate) SetStatus(s interface{}) {
	pc.Status = s.(ClusterRoleTemplateStatus)
}

func (pc *ClusterRoleTemplate) GetSpec() interface{} {
	return pc.Spec
}

func (pc *ClusterRoleTemplate) SetSpec(s interface{}) {
	pc.Spec = s.(ClusterRoleTemplateSpec)
}

func (pc *ClusterRoleTemplate) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *ClusterRoleTemplate) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc ClusterRoleTemplate) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store ClusterRoleTemplate.
// +k8s:deepcopy-gen=false
type ClusterRoleTemplateRegistry interface {
	ListClusterRoleTemplates(ctx context.Context, options *internalversion.ListOptions) (*ClusterRoleTemplateList, error)
	GetClusterRoleTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterRoleTemplate, error)
	CreateClusterRoleTemplate(ctx context.Context, id *ClusterRoleTemplate) (*ClusterRoleTemplate, error)
	UpdateClusterRoleTemplate(ctx context.Context, id *ClusterRoleTemplate) (*ClusterRoleTemplate, error)
	DeleteClusterRoleTemplate(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewClusterRoleTemplateRegistry(sp builders.StandardStorageProvider) ClusterRoleTemplateRegistry {
	return &storageClusterRoleTemplate{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageClusterRoleTemplate struct {
	builders.StandardStorageProvider
}

func (s *storageClusterRoleTemplate) ListClusterRoleTemplates(ctx context.Context, options *internalversion.ListOptions) (*ClusterRoleTemplateList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterRoleTemplateList), err
}

func (s *storageClusterRoleTemplate) GetClusterRoleTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterRoleTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterRoleTemplate), nil
}

func (s *storageClusterRoleTemplate) CreateClusterRoleTemplate(ctx context.Context, object *ClusterRoleTemplate) (*ClusterRoleTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterRoleTemplate), nil
}

func (s *storageClusterRoleTemplate) UpdateClusterRoleTemplate(ctx context.Context, object *ClusterRoleTemplate) (*ClusterRoleTemplate, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterRoleTemplate), nil
}

func (s *storageClusterRoleTemplate) DeleteClusterRoleTemplate(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Config Functions and Structs
//
// +k8s:deepcopy-gen=false
type ConfigStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ConfigStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ConfigList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Config
}

func (Config) NewStatus() interface{} {
	return ConfigStatus{}
}

func (pc *Config) GetStatus() interface{} {
	return pc.Status
}

func (pc *Config) SetStatus(s interface{}) {
	pc.Status = s.(ConfigStatus)
}

func (pc *Config) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Config) SetSpec(s interface{}) {
	pc.Spec = s.(ConfigSpec)
}

func (pc *Config) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Config) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Config) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Config.
// +k8s:deepcopy-gen=false
type ConfigRegistry interface {
	ListConfigs(ctx context.Context, options *internalversion.ListOptions) (*ConfigList, error)
	GetConfig(ctx context.Context, id string, options *metav1.GetOptions) (*Config, error)
	CreateConfig(ctx context.Context, id *Config) (*Config, error)
	UpdateConfig(ctx context.Context, id *Config) (*Config, error)
	DeleteConfig(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewConfigRegistry(sp builders.StandardStorageProvider) ConfigRegistry {
	return &storageConfig{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageConfig struct {
	builders.StandardStorageProvider
}

func (s *storageConfig) ListConfigs(ctx context.Context, options *internalversion.ListOptions) (*ConfigList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ConfigList), err
}

func (s *storageConfig) GetConfig(ctx context.Context, id string, options *metav1.GetOptions) (*Config, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Config), nil
}

func (s *storageConfig) CreateConfig(ctx context.Context, object *Config) (*Config, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Config), nil
}

func (s *storageConfig) UpdateConfig(ctx context.Context, object *Config) (*Config, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Config), nil
}

func (s *storageConfig) DeleteConfig(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// DevPodWorkspaceInstance Functions and Structs
//
// +k8s:deepcopy-gen=false
type DevPodWorkspaceInstanceStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type DevPodWorkspaceInstanceStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []DevPodWorkspaceInstance
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceDeleteList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []DevPodWorkspaceInstanceDelete
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceGetStatusList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []DevPodWorkspaceInstanceGetStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceSshList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []DevPodWorkspaceInstanceSsh
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceStopList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []DevPodWorkspaceInstanceStop
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceUpList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []DevPodWorkspaceInstanceUp
}

func (DevPodWorkspaceInstance) NewStatus() interface{} {
	return DevPodWorkspaceInstanceStatus{}
}

func (pc *DevPodWorkspaceInstance) GetStatus() interface{} {
	return pc.Status
}

func (pc *DevPodWorkspaceInstance) SetStatus(s interface{}) {
	pc.Status = s.(DevPodWorkspaceInstanceStatus)
}

func (pc *DevPodWorkspaceInstance) GetSpec() interface{} {
	return pc.Spec
}

func (pc *DevPodWorkspaceInstance) SetSpec(s interface{}) {
	pc.Spec = s.(DevPodWorkspaceInstanceSpec)
}

func (pc *DevPodWorkspaceInstance) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *DevPodWorkspaceInstance) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc DevPodWorkspaceInstance) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store DevPodWorkspaceInstance.
// +k8s:deepcopy-gen=false
type DevPodWorkspaceInstanceRegistry interface {
	ListDevPodWorkspaceInstances(ctx context.Context, options *internalversion.ListOptions) (*DevPodWorkspaceInstanceList, error)
	GetDevPodWorkspaceInstance(ctx context.Context, id string, options *metav1.GetOptions) (*DevPodWorkspaceInstance, error)
	CreateDevPodWorkspaceInstance(ctx context.Context, id *DevPodWorkspaceInstance) (*DevPodWorkspaceInstance, error)
	UpdateDevPodWorkspaceInstance(ctx context.Context, id *DevPodWorkspaceInstance) (*DevPodWorkspaceInstance, error)
	DeleteDevPodWorkspaceInstance(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewDevPodWorkspaceInstanceRegistry(sp builders.StandardStorageProvider) DevPodWorkspaceInstanceRegistry {
	return &storageDevPodWorkspaceInstance{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageDevPodWorkspaceInstance struct {
	builders.StandardStorageProvider
}

func (s *storageDevPodWorkspaceInstance) ListDevPodWorkspaceInstances(ctx context.Context, options *internalversion.ListOptions) (*DevPodWorkspaceInstanceList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceInstanceList), err
}

func (s *storageDevPodWorkspaceInstance) GetDevPodWorkspaceInstance(ctx context.Context, id string, options *metav1.GetOptions) (*DevPodWorkspaceInstance, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceInstance), nil
}

func (s *storageDevPodWorkspaceInstance) CreateDevPodWorkspaceInstance(ctx context.Context, object *DevPodWorkspaceInstance) (*DevPodWorkspaceInstance, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceInstance), nil
}

func (s *storageDevPodWorkspaceInstance) UpdateDevPodWorkspaceInstance(ctx context.Context, object *DevPodWorkspaceInstance) (*DevPodWorkspaceInstance, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceInstance), nil
}

func (s *storageDevPodWorkspaceInstance) DeleteDevPodWorkspaceInstance(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// DevPodWorkspaceTemplate Functions and Structs
//
// +k8s:deepcopy-gen=false
type DevPodWorkspaceTemplateStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type DevPodWorkspaceTemplateStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceTemplateList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []DevPodWorkspaceTemplate
}

func (DevPodWorkspaceTemplate) NewStatus() interface{} {
	return DevPodWorkspaceTemplateStatus{}
}

func (pc *DevPodWorkspaceTemplate) GetStatus() interface{} {
	return pc.Status
}

func (pc *DevPodWorkspaceTemplate) SetStatus(s interface{}) {
	pc.Status = s.(DevPodWorkspaceTemplateStatus)
}

func (pc *DevPodWorkspaceTemplate) GetSpec() interface{} {
	return pc.Spec
}

func (pc *DevPodWorkspaceTemplate) SetSpec(s interface{}) {
	pc.Spec = s.(DevPodWorkspaceTemplateSpec)
}

func (pc *DevPodWorkspaceTemplate) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *DevPodWorkspaceTemplate) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc DevPodWorkspaceTemplate) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store DevPodWorkspaceTemplate.
// +k8s:deepcopy-gen=false
type DevPodWorkspaceTemplateRegistry interface {
	ListDevPodWorkspaceTemplates(ctx context.Context, options *internalversion.ListOptions) (*DevPodWorkspaceTemplateList, error)
	GetDevPodWorkspaceTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*DevPodWorkspaceTemplate, error)
	CreateDevPodWorkspaceTemplate(ctx context.Context, id *DevPodWorkspaceTemplate) (*DevPodWorkspaceTemplate, error)
	UpdateDevPodWorkspaceTemplate(ctx context.Context, id *DevPodWorkspaceTemplate) (*DevPodWorkspaceTemplate, error)
	DeleteDevPodWorkspaceTemplate(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewDevPodWorkspaceTemplateRegistry(sp builders.StandardStorageProvider) DevPodWorkspaceTemplateRegistry {
	return &storageDevPodWorkspaceTemplate{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageDevPodWorkspaceTemplate struct {
	builders.StandardStorageProvider
}

func (s *storageDevPodWorkspaceTemplate) ListDevPodWorkspaceTemplates(ctx context.Context, options *internalversion.ListOptions) (*DevPodWorkspaceTemplateList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceTemplateList), err
}

func (s *storageDevPodWorkspaceTemplate) GetDevPodWorkspaceTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*DevPodWorkspaceTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceTemplate), nil
}

func (s *storageDevPodWorkspaceTemplate) CreateDevPodWorkspaceTemplate(ctx context.Context, object *DevPodWorkspaceTemplate) (*DevPodWorkspaceTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceTemplate), nil
}

func (s *storageDevPodWorkspaceTemplate) UpdateDevPodWorkspaceTemplate(ctx context.Context, object *DevPodWorkspaceTemplate) (*DevPodWorkspaceTemplate, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceTemplate), nil
}

func (s *storageDevPodWorkspaceTemplate) DeleteDevPodWorkspaceTemplate(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// DirectClusterEndpointToken Functions and Structs
//
// +k8s:deepcopy-gen=false
type DirectClusterEndpointTokenStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type DirectClusterEndpointTokenStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DirectClusterEndpointTokenList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []DirectClusterEndpointToken
}

func (DirectClusterEndpointToken) NewStatus() interface{} {
	return DirectClusterEndpointTokenStatus{}
}

func (pc *DirectClusterEndpointToken) GetStatus() interface{} {
	return pc.Status
}

func (pc *DirectClusterEndpointToken) SetStatus(s interface{}) {
	pc.Status = s.(DirectClusterEndpointTokenStatus)
}

func (pc *DirectClusterEndpointToken) GetSpec() interface{} {
	return pc.Spec
}

func (pc *DirectClusterEndpointToken) SetSpec(s interface{}) {
	pc.Spec = s.(DirectClusterEndpointTokenSpec)
}

func (pc *DirectClusterEndpointToken) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *DirectClusterEndpointToken) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc DirectClusterEndpointToken) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store DirectClusterEndpointToken.
// +k8s:deepcopy-gen=false
type DirectClusterEndpointTokenRegistry interface {
	ListDirectClusterEndpointTokens(ctx context.Context, options *internalversion.ListOptions) (*DirectClusterEndpointTokenList, error)
	GetDirectClusterEndpointToken(ctx context.Context, id string, options *metav1.GetOptions) (*DirectClusterEndpointToken, error)
	CreateDirectClusterEndpointToken(ctx context.Context, id *DirectClusterEndpointToken) (*DirectClusterEndpointToken, error)
	UpdateDirectClusterEndpointToken(ctx context.Context, id *DirectClusterEndpointToken) (*DirectClusterEndpointToken, error)
	DeleteDirectClusterEndpointToken(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewDirectClusterEndpointTokenRegistry(sp builders.StandardStorageProvider) DirectClusterEndpointTokenRegistry {
	return &storageDirectClusterEndpointToken{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageDirectClusterEndpointToken struct {
	builders.StandardStorageProvider
}

func (s *storageDirectClusterEndpointToken) ListDirectClusterEndpointTokens(ctx context.Context, options *internalversion.ListOptions) (*DirectClusterEndpointTokenList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DirectClusterEndpointTokenList), err
}

func (s *storageDirectClusterEndpointToken) GetDirectClusterEndpointToken(ctx context.Context, id string, options *metav1.GetOptions) (*DirectClusterEndpointToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DirectClusterEndpointToken), nil
}

func (s *storageDirectClusterEndpointToken) CreateDirectClusterEndpointToken(ctx context.Context, object *DirectClusterEndpointToken) (*DirectClusterEndpointToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DirectClusterEndpointToken), nil
}

func (s *storageDirectClusterEndpointToken) UpdateDirectClusterEndpointToken(ctx context.Context, object *DirectClusterEndpointToken) (*DirectClusterEndpointToken, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DirectClusterEndpointToken), nil
}

func (s *storageDirectClusterEndpointToken) DeleteDirectClusterEndpointToken(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Event Functions and Structs
//
// +k8s:deepcopy-gen=false
type EventStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type EventStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type EventList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Event
}

func (Event) NewStatus() interface{} {
	return EventStatus{}
}

func (pc *Event) GetStatus() interface{} {
	return pc.Status
}

func (pc *Event) SetStatus(s interface{}) {
	pc.Status = s.(EventStatus)
}

func (pc *Event) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Event) SetSpec(s interface{}) {
	pc.Spec = s.(EventSpec)
}

func (pc *Event) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Event) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Event) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Event.
// +k8s:deepcopy-gen=false
type EventRegistry interface {
	ListEvents(ctx context.Context, options *internalversion.ListOptions) (*EventList, error)
	GetEvent(ctx context.Context, id string, options *metav1.GetOptions) (*Event, error)
	CreateEvent(ctx context.Context, id *Event) (*Event, error)
	UpdateEvent(ctx context.Context, id *Event) (*Event, error)
	DeleteEvent(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewEventRegistry(sp builders.StandardStorageProvider) EventRegistry {
	return &storageEvent{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageEvent struct {
	builders.StandardStorageProvider
}

func (s *storageEvent) ListEvents(ctx context.Context, options *internalversion.ListOptions) (*EventList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*EventList), err
}

func (s *storageEvent) GetEvent(ctx context.Context, id string, options *metav1.GetOptions) (*Event, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Event), nil
}

func (s *storageEvent) CreateEvent(ctx context.Context, object *Event) (*Event, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Event), nil
}

func (s *storageEvent) UpdateEvent(ctx context.Context, object *Event) (*Event, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Event), nil
}

func (s *storageEvent) DeleteEvent(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Feature Functions and Structs
//
// +k8s:deepcopy-gen=false
type FeatureStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type FeatureStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type FeatureList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Feature
}

func (Feature) NewStatus() interface{} {
	return FeatureStatus{}
}

func (pc *Feature) GetStatus() interface{} {
	return pc.Status
}

func (pc *Feature) SetStatus(s interface{}) {
	pc.Status = s.(FeatureStatus)
}

func (pc *Feature) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Feature) SetSpec(s interface{}) {
	pc.Spec = s.(FeatureSpec)
}

func (pc *Feature) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Feature) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Feature) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Feature.
// +k8s:deepcopy-gen=false
type FeatureRegistry interface {
	ListFeatures(ctx context.Context, options *internalversion.ListOptions) (*FeatureList, error)
	GetFeature(ctx context.Context, id string, options *metav1.GetOptions) (*Feature, error)
	CreateFeature(ctx context.Context, id *Feature) (*Feature, error)
	UpdateFeature(ctx context.Context, id *Feature) (*Feature, error)
	DeleteFeature(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewFeatureRegistry(sp builders.StandardStorageProvider) FeatureRegistry {
	return &storageFeature{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageFeature struct {
	builders.StandardStorageProvider
}

func (s *storageFeature) ListFeatures(ctx context.Context, options *internalversion.ListOptions) (*FeatureList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*FeatureList), err
}

func (s *storageFeature) GetFeature(ctx context.Context, id string, options *metav1.GetOptions) (*Feature, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Feature), nil
}

func (s *storageFeature) CreateFeature(ctx context.Context, object *Feature) (*Feature, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Feature), nil
}

func (s *storageFeature) UpdateFeature(ctx context.Context, object *Feature) (*Feature, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Feature), nil
}

func (s *storageFeature) DeleteFeature(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// IngressAuthToken Functions and Structs
//
// +k8s:deepcopy-gen=false
type IngressAuthTokenStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type IngressAuthTokenStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type IngressAuthTokenList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []IngressAuthToken
}

func (IngressAuthToken) NewStatus() interface{} {
	return IngressAuthTokenStatus{}
}

func (pc *IngressAuthToken) GetStatus() interface{} {
	return pc.Status
}

func (pc *IngressAuthToken) SetStatus(s interface{}) {
	pc.Status = s.(IngressAuthTokenStatus)
}

func (pc *IngressAuthToken) GetSpec() interface{} {
	return pc.Spec
}

func (pc *IngressAuthToken) SetSpec(s interface{}) {
	pc.Spec = s.(IngressAuthTokenSpec)
}

func (pc *IngressAuthToken) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *IngressAuthToken) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc IngressAuthToken) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store IngressAuthToken.
// +k8s:deepcopy-gen=false
type IngressAuthTokenRegistry interface {
	ListIngressAuthTokens(ctx context.Context, options *internalversion.ListOptions) (*IngressAuthTokenList, error)
	GetIngressAuthToken(ctx context.Context, id string, options *metav1.GetOptions) (*IngressAuthToken, error)
	CreateIngressAuthToken(ctx context.Context, id *IngressAuthToken) (*IngressAuthToken, error)
	UpdateIngressAuthToken(ctx context.Context, id *IngressAuthToken) (*IngressAuthToken, error)
	DeleteIngressAuthToken(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewIngressAuthTokenRegistry(sp builders.StandardStorageProvider) IngressAuthTokenRegistry {
	return &storageIngressAuthToken{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageIngressAuthToken struct {
	builders.StandardStorageProvider
}

func (s *storageIngressAuthToken) ListIngressAuthTokens(ctx context.Context, options *internalversion.ListOptions) (*IngressAuthTokenList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*IngressAuthTokenList), err
}

func (s *storageIngressAuthToken) GetIngressAuthToken(ctx context.Context, id string, options *metav1.GetOptions) (*IngressAuthToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*IngressAuthToken), nil
}

func (s *storageIngressAuthToken) CreateIngressAuthToken(ctx context.Context, object *IngressAuthToken) (*IngressAuthToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*IngressAuthToken), nil
}

func (s *storageIngressAuthToken) UpdateIngressAuthToken(ctx context.Context, object *IngressAuthToken) (*IngressAuthToken, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*IngressAuthToken), nil
}

func (s *storageIngressAuthToken) DeleteIngressAuthToken(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Kiosk Functions and Structs
//
// +k8s:deepcopy-gen=false
type KioskStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type KioskStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type KioskList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Kiosk
}

func (Kiosk) NewStatus() interface{} {
	return KioskStatus{}
}

func (pc *Kiosk) GetStatus() interface{} {
	return pc.Status
}

func (pc *Kiosk) SetStatus(s interface{}) {
	pc.Status = s.(KioskStatus)
}

func (pc *Kiosk) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Kiosk) SetSpec(s interface{}) {
	pc.Spec = s.(KioskSpec)
}

func (pc *Kiosk) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Kiosk) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Kiosk) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Kiosk.
// +k8s:deepcopy-gen=false
type KioskRegistry interface {
	ListKiosks(ctx context.Context, options *internalversion.ListOptions) (*KioskList, error)
	GetKiosk(ctx context.Context, id string, options *metav1.GetOptions) (*Kiosk, error)
	CreateKiosk(ctx context.Context, id *Kiosk) (*Kiosk, error)
	UpdateKiosk(ctx context.Context, id *Kiosk) (*Kiosk, error)
	DeleteKiosk(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewKioskRegistry(sp builders.StandardStorageProvider) KioskRegistry {
	return &storageKiosk{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageKiosk struct {
	builders.StandardStorageProvider
}

func (s *storageKiosk) ListKiosks(ctx context.Context, options *internalversion.ListOptions) (*KioskList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*KioskList), err
}

func (s *storageKiosk) GetKiosk(ctx context.Context, id string, options *metav1.GetOptions) (*Kiosk, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Kiosk), nil
}

func (s *storageKiosk) CreateKiosk(ctx context.Context, object *Kiosk) (*Kiosk, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Kiosk), nil
}

func (s *storageKiosk) UpdateKiosk(ctx context.Context, object *Kiosk) (*Kiosk, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Kiosk), nil
}

func (s *storageKiosk) DeleteKiosk(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// License Functions and Structs
//
// +k8s:deepcopy-gen=false
type LicenseStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type LicenseStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []License
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseRequestList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []LicenseRequest
}

func (License) NewStatus() interface{} {
	return LicenseStatus{}
}

func (pc *License) GetStatus() interface{} {
	return pc.Status
}

func (pc *License) SetStatus(s interface{}) {
	pc.Status = s.(LicenseStatus)
}

func (pc *License) GetSpec() interface{} {
	return pc.Spec
}

func (pc *License) SetSpec(s interface{}) {
	pc.Spec = s.(LicenseSpec)
}

func (pc *License) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *License) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc License) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store License.
// +k8s:deepcopy-gen=false
type LicenseRegistry interface {
	ListLicenses(ctx context.Context, options *internalversion.ListOptions) (*LicenseList, error)
	GetLicense(ctx context.Context, id string, options *metav1.GetOptions) (*License, error)
	CreateLicense(ctx context.Context, id *License) (*License, error)
	UpdateLicense(ctx context.Context, id *License) (*License, error)
	DeleteLicense(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewLicenseRegistry(sp builders.StandardStorageProvider) LicenseRegistry {
	return &storageLicense{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageLicense struct {
	builders.StandardStorageProvider
}

func (s *storageLicense) ListLicenses(ctx context.Context, options *internalversion.ListOptions) (*LicenseList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseList), err
}

func (s *storageLicense) GetLicense(ctx context.Context, id string, options *metav1.GetOptions) (*License, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*License), nil
}

func (s *storageLicense) CreateLicense(ctx context.Context, object *License) (*License, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*License), nil
}

func (s *storageLicense) UpdateLicense(ctx context.Context, object *License) (*License, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*License), nil
}

func (s *storageLicense) DeleteLicense(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// LicenseToken Functions and Structs
//
// +k8s:deepcopy-gen=false
type LicenseTokenStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type LicenseTokenStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseTokenList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []LicenseToken
}

func (LicenseToken) NewStatus() interface{} {
	return LicenseTokenStatus{}
}

func (pc *LicenseToken) GetStatus() interface{} {
	return pc.Status
}

func (pc *LicenseToken) SetStatus(s interface{}) {
	pc.Status = s.(LicenseTokenStatus)
}

func (pc *LicenseToken) GetSpec() interface{} {
	return pc.Spec
}

func (pc *LicenseToken) SetSpec(s interface{}) {
	pc.Spec = s.(LicenseTokenSpec)
}

func (pc *LicenseToken) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *LicenseToken) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc LicenseToken) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store LicenseToken.
// +k8s:deepcopy-gen=false
type LicenseTokenRegistry interface {
	ListLicenseTokens(ctx context.Context, options *internalversion.ListOptions) (*LicenseTokenList, error)
	GetLicenseToken(ctx context.Context, id string, options *metav1.GetOptions) (*LicenseToken, error)
	CreateLicenseToken(ctx context.Context, id *LicenseToken) (*LicenseToken, error)
	UpdateLicenseToken(ctx context.Context, id *LicenseToken) (*LicenseToken, error)
	DeleteLicenseToken(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewLicenseTokenRegistry(sp builders.StandardStorageProvider) LicenseTokenRegistry {
	return &storageLicenseToken{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageLicenseToken struct {
	builders.StandardStorageProvider
}

func (s *storageLicenseToken) ListLicenseTokens(ctx context.Context, options *internalversion.ListOptions) (*LicenseTokenList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseTokenList), err
}

func (s *storageLicenseToken) GetLicenseToken(ctx context.Context, id string, options *metav1.GetOptions) (*LicenseToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseToken), nil
}

func (s *storageLicenseToken) CreateLicenseToken(ctx context.Context, object *LicenseToken) (*LicenseToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseToken), nil
}

func (s *storageLicenseToken) UpdateLicenseToken(ctx context.Context, object *LicenseToken) (*LicenseToken, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseToken), nil
}

func (s *storageLicenseToken) DeleteLicenseToken(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// LoftUpgrade Functions and Structs
//
// +k8s:deepcopy-gen=false
type LoftUpgradeStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type LoftUpgradeStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LoftUpgradeList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []LoftUpgrade
}

func (LoftUpgrade) NewStatus() interface{} {
	return LoftUpgradeStatus{}
}

func (pc *LoftUpgrade) GetStatus() interface{} {
	return pc.Status
}

func (pc *LoftUpgrade) SetStatus(s interface{}) {
	pc.Status = s.(LoftUpgradeStatus)
}

func (pc *LoftUpgrade) GetSpec() interface{} {
	return pc.Spec
}

func (pc *LoftUpgrade) SetSpec(s interface{}) {
	pc.Spec = s.(LoftUpgradeSpec)
}

func (pc *LoftUpgrade) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *LoftUpgrade) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc LoftUpgrade) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store LoftUpgrade.
// +k8s:deepcopy-gen=false
type LoftUpgradeRegistry interface {
	ListLoftUpgrades(ctx context.Context, options *internalversion.ListOptions) (*LoftUpgradeList, error)
	GetLoftUpgrade(ctx context.Context, id string, options *metav1.GetOptions) (*LoftUpgrade, error)
	CreateLoftUpgrade(ctx context.Context, id *LoftUpgrade) (*LoftUpgrade, error)
	UpdateLoftUpgrade(ctx context.Context, id *LoftUpgrade) (*LoftUpgrade, error)
	DeleteLoftUpgrade(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewLoftUpgradeRegistry(sp builders.StandardStorageProvider) LoftUpgradeRegistry {
	return &storageLoftUpgrade{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageLoftUpgrade struct {
	builders.StandardStorageProvider
}

func (s *storageLoftUpgrade) ListLoftUpgrades(ctx context.Context, options *internalversion.ListOptions) (*LoftUpgradeList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LoftUpgradeList), err
}

func (s *storageLoftUpgrade) GetLoftUpgrade(ctx context.Context, id string, options *metav1.GetOptions) (*LoftUpgrade, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LoftUpgrade), nil
}

func (s *storageLoftUpgrade) CreateLoftUpgrade(ctx context.Context, object *LoftUpgrade) (*LoftUpgrade, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*LoftUpgrade), nil
}

func (s *storageLoftUpgrade) UpdateLoftUpgrade(ctx context.Context, object *LoftUpgrade) (*LoftUpgrade, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*LoftUpgrade), nil
}

func (s *storageLoftUpgrade) DeleteLoftUpgrade(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// OwnedAccessKey Functions and Structs
//
// +k8s:deepcopy-gen=false
type OwnedAccessKeyStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type OwnedAccessKeyStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type OwnedAccessKeyList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []OwnedAccessKey
}

func (OwnedAccessKey) NewStatus() interface{} {
	return OwnedAccessKeyStatus{}
}

func (pc *OwnedAccessKey) GetStatus() interface{} {
	return pc.Status
}

func (pc *OwnedAccessKey) SetStatus(s interface{}) {
	pc.Status = s.(OwnedAccessKeyStatus)
}

func (pc *OwnedAccessKey) GetSpec() interface{} {
	return pc.Spec
}

func (pc *OwnedAccessKey) SetSpec(s interface{}) {
	pc.Spec = s.(OwnedAccessKeySpec)
}

func (pc *OwnedAccessKey) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *OwnedAccessKey) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc OwnedAccessKey) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store OwnedAccessKey.
// +k8s:deepcopy-gen=false
type OwnedAccessKeyRegistry interface {
	ListOwnedAccessKeys(ctx context.Context, options *internalversion.ListOptions) (*OwnedAccessKeyList, error)
	GetOwnedAccessKey(ctx context.Context, id string, options *metav1.GetOptions) (*OwnedAccessKey, error)
	CreateOwnedAccessKey(ctx context.Context, id *OwnedAccessKey) (*OwnedAccessKey, error)
	UpdateOwnedAccessKey(ctx context.Context, id *OwnedAccessKey) (*OwnedAccessKey, error)
	DeleteOwnedAccessKey(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewOwnedAccessKeyRegistry(sp builders.StandardStorageProvider) OwnedAccessKeyRegistry {
	return &storageOwnedAccessKey{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageOwnedAccessKey struct {
	builders.StandardStorageProvider
}

func (s *storageOwnedAccessKey) ListOwnedAccessKeys(ctx context.Context, options *internalversion.ListOptions) (*OwnedAccessKeyList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*OwnedAccessKeyList), err
}

func (s *storageOwnedAccessKey) GetOwnedAccessKey(ctx context.Context, id string, options *metav1.GetOptions) (*OwnedAccessKey, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*OwnedAccessKey), nil
}

func (s *storageOwnedAccessKey) CreateOwnedAccessKey(ctx context.Context, object *OwnedAccessKey) (*OwnedAccessKey, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*OwnedAccessKey), nil
}

func (s *storageOwnedAccessKey) UpdateOwnedAccessKey(ctx context.Context, object *OwnedAccessKey) (*OwnedAccessKey, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*OwnedAccessKey), nil
}

func (s *storageOwnedAccessKey) DeleteOwnedAccessKey(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// PolicyViolation Functions and Structs
//
// +k8s:deepcopy-gen=false
type PolicyViolationStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type PolicyViolationStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type PolicyViolationList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []PolicyViolation
}

func (PolicyViolation) NewStatus() interface{} {
	return PolicyViolationStatus{}
}

func (pc *PolicyViolation) GetStatus() interface{} {
	return pc.Status
}

func (pc *PolicyViolation) SetStatus(s interface{}) {
	pc.Status = s.(PolicyViolationStatus)
}

func (pc *PolicyViolation) GetSpec() interface{} {
	return pc.Spec
}

func (pc *PolicyViolation) SetSpec(s interface{}) {
	pc.Spec = s.(PolicyViolationSpec)
}

func (pc *PolicyViolation) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *PolicyViolation) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc PolicyViolation) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store PolicyViolation.
// +k8s:deepcopy-gen=false
type PolicyViolationRegistry interface {
	ListPolicyViolations(ctx context.Context, options *internalversion.ListOptions) (*PolicyViolationList, error)
	GetPolicyViolation(ctx context.Context, id string, options *metav1.GetOptions) (*PolicyViolation, error)
	CreatePolicyViolation(ctx context.Context, id *PolicyViolation) (*PolicyViolation, error)
	UpdatePolicyViolation(ctx context.Context, id *PolicyViolation) (*PolicyViolation, error)
	DeletePolicyViolation(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewPolicyViolationRegistry(sp builders.StandardStorageProvider) PolicyViolationRegistry {
	return &storagePolicyViolation{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storagePolicyViolation struct {
	builders.StandardStorageProvider
}

func (s *storagePolicyViolation) ListPolicyViolations(ctx context.Context, options *internalversion.ListOptions) (*PolicyViolationList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*PolicyViolationList), err
}

func (s *storagePolicyViolation) GetPolicyViolation(ctx context.Context, id string, options *metav1.GetOptions) (*PolicyViolation, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*PolicyViolation), nil
}

func (s *storagePolicyViolation) CreatePolicyViolation(ctx context.Context, object *PolicyViolation) (*PolicyViolation, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*PolicyViolation), nil
}

func (s *storagePolicyViolation) UpdatePolicyViolation(ctx context.Context, object *PolicyViolation) (*PolicyViolation, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*PolicyViolation), nil
}

func (s *storagePolicyViolation) DeletePolicyViolation(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Project Functions and Structs
//
// +k8s:deepcopy-gen=false
type ProjectStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ProjectStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Project
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectChartInfoList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ProjectChartInfo
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectChartsList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ProjectCharts
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectClustersList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ProjectClusters
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectImportSpaceList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ProjectImportSpace
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectImportVirtualClusterList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ProjectImportVirtualCluster
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectMembersList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ProjectMembers
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectMigrateSpaceInstanceList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ProjectMigrateSpaceInstance
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectMigrateVirtualClusterInstanceList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ProjectMigrateVirtualClusterInstance
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectTemplatesList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ProjectTemplates
}

func (Project) NewStatus() interface{} {
	return ProjectStatus{}
}

func (pc *Project) GetStatus() interface{} {
	return pc.Status
}

func (pc *Project) SetStatus(s interface{}) {
	pc.Status = s.(ProjectStatus)
}

func (pc *Project) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Project) SetSpec(s interface{}) {
	pc.Spec = s.(ProjectSpec)
}

func (pc *Project) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Project) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Project) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Project.
// +k8s:deepcopy-gen=false
type ProjectRegistry interface {
	ListProjects(ctx context.Context, options *internalversion.ListOptions) (*ProjectList, error)
	GetProject(ctx context.Context, id string, options *metav1.GetOptions) (*Project, error)
	CreateProject(ctx context.Context, id *Project) (*Project, error)
	UpdateProject(ctx context.Context, id *Project) (*Project, error)
	DeleteProject(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewProjectRegistry(sp builders.StandardStorageProvider) ProjectRegistry {
	return &storageProject{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageProject struct {
	builders.StandardStorageProvider
}

func (s *storageProject) ListProjects(ctx context.Context, options *internalversion.ListOptions) (*ProjectList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ProjectList), err
}

func (s *storageProject) GetProject(ctx context.Context, id string, options *metav1.GetOptions) (*Project, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Project), nil
}

func (s *storageProject) CreateProject(ctx context.Context, object *Project) (*Project, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Project), nil
}

func (s *storageProject) UpdateProject(ctx context.Context, object *Project) (*Project, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Project), nil
}

func (s *storageProject) DeleteProject(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// ProjectSecret Functions and Structs
//
// +k8s:deepcopy-gen=false
type ProjectSecretStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ProjectSecretStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectSecretList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ProjectSecret
}

func (ProjectSecret) NewStatus() interface{} {
	return ProjectSecretStatus{}
}

func (pc *ProjectSecret) GetStatus() interface{} {
	return pc.Status
}

func (pc *ProjectSecret) SetStatus(s interface{}) {
	pc.Status = s.(ProjectSecretStatus)
}

func (pc *ProjectSecret) GetSpec() interface{} {
	return pc.Spec
}

func (pc *ProjectSecret) SetSpec(s interface{}) {
	pc.Spec = s.(ProjectSecretSpec)
}

func (pc *ProjectSecret) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *ProjectSecret) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc ProjectSecret) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store ProjectSecret.
// +k8s:deepcopy-gen=false
type ProjectSecretRegistry interface {
	ListProjectSecrets(ctx context.Context, options *internalversion.ListOptions) (*ProjectSecretList, error)
	GetProjectSecret(ctx context.Context, id string, options *metav1.GetOptions) (*ProjectSecret, error)
	CreateProjectSecret(ctx context.Context, id *ProjectSecret) (*ProjectSecret, error)
	UpdateProjectSecret(ctx context.Context, id *ProjectSecret) (*ProjectSecret, error)
	DeleteProjectSecret(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewProjectSecretRegistry(sp builders.StandardStorageProvider) ProjectSecretRegistry {
	return &storageProjectSecret{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageProjectSecret struct {
	builders.StandardStorageProvider
}

func (s *storageProjectSecret) ListProjectSecrets(ctx context.Context, options *internalversion.ListOptions) (*ProjectSecretList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ProjectSecretList), err
}

func (s *storageProjectSecret) GetProjectSecret(ctx context.Context, id string, options *metav1.GetOptions) (*ProjectSecret, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ProjectSecret), nil
}

func (s *storageProjectSecret) CreateProjectSecret(ctx context.Context, object *ProjectSecret) (*ProjectSecret, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ProjectSecret), nil
}

func (s *storageProjectSecret) UpdateProjectSecret(ctx context.Context, object *ProjectSecret) (*ProjectSecret, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ProjectSecret), nil
}

func (s *storageProjectSecret) DeleteProjectSecret(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// RedirectToken Functions and Structs
//
// +k8s:deepcopy-gen=false
type RedirectTokenStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type RedirectTokenStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type RedirectTokenList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []RedirectToken
}

func (RedirectToken) NewStatus() interface{} {
	return RedirectTokenStatus{}
}

func (pc *RedirectToken) GetStatus() interface{} {
	return pc.Status
}

func (pc *RedirectToken) SetStatus(s interface{}) {
	pc.Status = s.(RedirectTokenStatus)
}

func (pc *RedirectToken) GetSpec() interface{} {
	return pc.Spec
}

func (pc *RedirectToken) SetSpec(s interface{}) {
	pc.Spec = s.(RedirectTokenSpec)
}

func (pc *RedirectToken) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *RedirectToken) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc RedirectToken) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store RedirectToken.
// +k8s:deepcopy-gen=false
type RedirectTokenRegistry interface {
	ListRedirectTokens(ctx context.Context, options *internalversion.ListOptions) (*RedirectTokenList, error)
	GetRedirectToken(ctx context.Context, id string, options *metav1.GetOptions) (*RedirectToken, error)
	CreateRedirectToken(ctx context.Context, id *RedirectToken) (*RedirectToken, error)
	UpdateRedirectToken(ctx context.Context, id *RedirectToken) (*RedirectToken, error)
	DeleteRedirectToken(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewRedirectTokenRegistry(sp builders.StandardStorageProvider) RedirectTokenRegistry {
	return &storageRedirectToken{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageRedirectToken struct {
	builders.StandardStorageProvider
}

func (s *storageRedirectToken) ListRedirectTokens(ctx context.Context, options *internalversion.ListOptions) (*RedirectTokenList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*RedirectTokenList), err
}

func (s *storageRedirectToken) GetRedirectToken(ctx context.Context, id string, options *metav1.GetOptions) (*RedirectToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*RedirectToken), nil
}

func (s *storageRedirectToken) CreateRedirectToken(ctx context.Context, object *RedirectToken) (*RedirectToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*RedirectToken), nil
}

func (s *storageRedirectToken) UpdateRedirectToken(ctx context.Context, object *RedirectToken) (*RedirectToken, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*RedirectToken), nil
}

func (s *storageRedirectToken) DeleteRedirectToken(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// ResetAccessKey Functions and Structs
//
// +k8s:deepcopy-gen=false
type ResetAccessKeyStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ResetAccessKeyStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ResetAccessKeyList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []ResetAccessKey
}

func (ResetAccessKey) NewStatus() interface{} {
	return ResetAccessKeyStatus{}
}

func (pc *ResetAccessKey) GetStatus() interface{} {
	return pc.Status
}

func (pc *ResetAccessKey) SetStatus(s interface{}) {
	pc.Status = s.(ResetAccessKeyStatus)
}

func (pc *ResetAccessKey) GetSpec() interface{} {
	return pc.Spec
}

func (pc *ResetAccessKey) SetSpec(s interface{}) {
	pc.Spec = s.(ResetAccessKeySpec)
}

func (pc *ResetAccessKey) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *ResetAccessKey) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc ResetAccessKey) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store ResetAccessKey.
// +k8s:deepcopy-gen=false
type ResetAccessKeyRegistry interface {
	ListResetAccessKeys(ctx context.Context, options *internalversion.ListOptions) (*ResetAccessKeyList, error)
	GetResetAccessKey(ctx context.Context, id string, options *metav1.GetOptions) (*ResetAccessKey, error)
	CreateResetAccessKey(ctx context.Context, id *ResetAccessKey) (*ResetAccessKey, error)
	UpdateResetAccessKey(ctx context.Context, id *ResetAccessKey) (*ResetAccessKey, error)
	DeleteResetAccessKey(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewResetAccessKeyRegistry(sp builders.StandardStorageProvider) ResetAccessKeyRegistry {
	return &storageResetAccessKey{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageResetAccessKey struct {
	builders.StandardStorageProvider
}

func (s *storageResetAccessKey) ListResetAccessKeys(ctx context.Context, options *internalversion.ListOptions) (*ResetAccessKeyList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ResetAccessKeyList), err
}

func (s *storageResetAccessKey) GetResetAccessKey(ctx context.Context, id string, options *metav1.GetOptions) (*ResetAccessKey, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ResetAccessKey), nil
}

func (s *storageResetAccessKey) CreateResetAccessKey(ctx context.Context, object *ResetAccessKey) (*ResetAccessKey, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ResetAccessKey), nil
}

func (s *storageResetAccessKey) UpdateResetAccessKey(ctx context.Context, object *ResetAccessKey) (*ResetAccessKey, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ResetAccessKey), nil
}

func (s *storageResetAccessKey) DeleteResetAccessKey(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Runner Functions and Structs
//
// +k8s:deepcopy-gen=false
type RunnerStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type RunnerStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type RunnerList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Runner
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type RunnerAccessKeyList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []RunnerAccessKey
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type RunnerConfigList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []RunnerConfig
}

func (Runner) NewStatus() interface{} {
	return RunnerStatus{}
}

func (pc *Runner) GetStatus() interface{} {
	return pc.Status
}

func (pc *Runner) SetStatus(s interface{}) {
	pc.Status = s.(RunnerStatus)
}

func (pc *Runner) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Runner) SetSpec(s interface{}) {
	pc.Spec = s.(RunnerSpec)
}

func (pc *Runner) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Runner) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Runner) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Runner.
// +k8s:deepcopy-gen=false
type RunnerRegistry interface {
	ListRunners(ctx context.Context, options *internalversion.ListOptions) (*RunnerList, error)
	GetRunner(ctx context.Context, id string, options *metav1.GetOptions) (*Runner, error)
	CreateRunner(ctx context.Context, id *Runner) (*Runner, error)
	UpdateRunner(ctx context.Context, id *Runner) (*Runner, error)
	DeleteRunner(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewRunnerRegistry(sp builders.StandardStorageProvider) RunnerRegistry {
	return &storageRunner{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageRunner struct {
	builders.StandardStorageProvider
}

func (s *storageRunner) ListRunners(ctx context.Context, options *internalversion.ListOptions) (*RunnerList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*RunnerList), err
}

func (s *storageRunner) GetRunner(ctx context.Context, id string, options *metav1.GetOptions) (*Runner, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Runner), nil
}

func (s *storageRunner) CreateRunner(ctx context.Context, object *Runner) (*Runner, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Runner), nil
}

func (s *storageRunner) UpdateRunner(ctx context.Context, object *Runner) (*Runner, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Runner), nil
}

func (s *storageRunner) DeleteRunner(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Self Functions and Structs
//
// +k8s:deepcopy-gen=false
type SelfStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SelfStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SelfList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Self
}

func (Self) NewStatus() interface{} {
	return SelfStatus{}
}

func (pc *Self) GetStatus() interface{} {
	return pc.Status
}

func (pc *Self) SetStatus(s interface{}) {
	pc.Status = s.(SelfStatus)
}

func (pc *Self) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Self) SetSpec(s interface{}) {
	pc.Spec = s.(SelfSpec)
}

func (pc *Self) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Self) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Self) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Self.
// +k8s:deepcopy-gen=false
type SelfRegistry interface {
	ListSelfs(ctx context.Context, options *internalversion.ListOptions) (*SelfList, error)
	GetSelf(ctx context.Context, id string, options *metav1.GetOptions) (*Self, error)
	CreateSelf(ctx context.Context, id *Self) (*Self, error)
	UpdateSelf(ctx context.Context, id *Self) (*Self, error)
	DeleteSelf(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSelfRegistry(sp builders.StandardStorageProvider) SelfRegistry {
	return &storageSelf{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSelf struct {
	builders.StandardStorageProvider
}

func (s *storageSelf) ListSelfs(ctx context.Context, options *internalversion.ListOptions) (*SelfList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SelfList), err
}

func (s *storageSelf) GetSelf(ctx context.Context, id string, options *metav1.GetOptions) (*Self, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Self), nil
}

func (s *storageSelf) CreateSelf(ctx context.Context, object *Self) (*Self, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Self), nil
}

func (s *storageSelf) UpdateSelf(ctx context.Context, object *Self) (*Self, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Self), nil
}

func (s *storageSelf) DeleteSelf(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// SelfSubjectAccessReview Functions and Structs
//
// +k8s:deepcopy-gen=false
type SelfSubjectAccessReviewStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SelfSubjectAccessReviewStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SelfSubjectAccessReviewList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []SelfSubjectAccessReview
}

func (SelfSubjectAccessReview) NewStatus() interface{} {
	return SelfSubjectAccessReviewStatus{}
}

func (pc *SelfSubjectAccessReview) GetStatus() interface{} {
	return pc.Status
}

func (pc *SelfSubjectAccessReview) SetStatus(s interface{}) {
	pc.Status = s.(SelfSubjectAccessReviewStatus)
}

func (pc *SelfSubjectAccessReview) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SelfSubjectAccessReview) SetSpec(s interface{}) {
	pc.Spec = s.(SelfSubjectAccessReviewSpec)
}

func (pc *SelfSubjectAccessReview) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SelfSubjectAccessReview) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SelfSubjectAccessReview) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SelfSubjectAccessReview.
// +k8s:deepcopy-gen=false
type SelfSubjectAccessReviewRegistry interface {
	ListSelfSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SelfSubjectAccessReviewList, error)
	GetSelfSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SelfSubjectAccessReview, error)
	CreateSelfSubjectAccessReview(ctx context.Context, id *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error)
	UpdateSelfSubjectAccessReview(ctx context.Context, id *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error)
	DeleteSelfSubjectAccessReview(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSelfSubjectAccessReviewRegistry(sp builders.StandardStorageProvider) SelfSubjectAccessReviewRegistry {
	return &storageSelfSubjectAccessReview{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSelfSubjectAccessReview struct {
	builders.StandardStorageProvider
}

func (s *storageSelfSubjectAccessReview) ListSelfSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SelfSubjectAccessReviewList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReviewList), err
}

func (s *storageSelfSubjectAccessReview) GetSelfSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SelfSubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReview), nil
}

func (s *storageSelfSubjectAccessReview) CreateSelfSubjectAccessReview(ctx context.Context, object *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReview), nil
}

func (s *storageSelfSubjectAccessReview) UpdateSelfSubjectAccessReview(ctx context.Context, object *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReview), nil
}

func (s *storageSelfSubjectAccessReview) DeleteSelfSubjectAccessReview(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// SharedSecret Functions and Structs
//
// +k8s:deepcopy-gen=false
type SharedSecretStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SharedSecretStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SharedSecretList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []SharedSecret
}

func (SharedSecret) NewStatus() interface{} {
	return SharedSecretStatus{}
}

func (pc *SharedSecret) GetStatus() interface{} {
	return pc.Status
}

func (pc *SharedSecret) SetStatus(s interface{}) {
	pc.Status = s.(SharedSecretStatus)
}

func (pc *SharedSecret) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SharedSecret) SetSpec(s interface{}) {
	pc.Spec = s.(SharedSecretSpec)
}

func (pc *SharedSecret) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SharedSecret) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SharedSecret) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SharedSecret.
// +k8s:deepcopy-gen=false
type SharedSecretRegistry interface {
	ListSharedSecrets(ctx context.Context, options *internalversion.ListOptions) (*SharedSecretList, error)
	GetSharedSecret(ctx context.Context, id string, options *metav1.GetOptions) (*SharedSecret, error)
	CreateSharedSecret(ctx context.Context, id *SharedSecret) (*SharedSecret, error)
	UpdateSharedSecret(ctx context.Context, id *SharedSecret) (*SharedSecret, error)
	DeleteSharedSecret(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSharedSecretRegistry(sp builders.StandardStorageProvider) SharedSecretRegistry {
	return &storageSharedSecret{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSharedSecret struct {
	builders.StandardStorageProvider
}

func (s *storageSharedSecret) ListSharedSecrets(ctx context.Context, options *internalversion.ListOptions) (*SharedSecretList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SharedSecretList), err
}

func (s *storageSharedSecret) GetSharedSecret(ctx context.Context, id string, options *metav1.GetOptions) (*SharedSecret, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SharedSecret), nil
}

func (s *storageSharedSecret) CreateSharedSecret(ctx context.Context, object *SharedSecret) (*SharedSecret, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SharedSecret), nil
}

func (s *storageSharedSecret) UpdateSharedSecret(ctx context.Context, object *SharedSecret) (*SharedSecret, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SharedSecret), nil
}

func (s *storageSharedSecret) DeleteSharedSecret(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// SpaceConstraint Functions and Structs
//
// +k8s:deepcopy-gen=false
type SpaceConstraintStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SpaceConstraintStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SpaceConstraintList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []SpaceConstraint
}

func (SpaceConstraint) NewStatus() interface{} {
	return SpaceConstraintStatus{}
}

func (pc *SpaceConstraint) GetStatus() interface{} {
	return pc.Status
}

func (pc *SpaceConstraint) SetStatus(s interface{}) {
	pc.Status = s.(SpaceConstraintStatus)
}

func (pc *SpaceConstraint) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SpaceConstraint) SetSpec(s interface{}) {
	pc.Spec = s.(SpaceConstraintSpec)
}

func (pc *SpaceConstraint) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SpaceConstraint) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SpaceConstraint) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SpaceConstraint.
// +k8s:deepcopy-gen=false
type SpaceConstraintRegistry interface {
	ListSpaceConstraints(ctx context.Context, options *internalversion.ListOptions) (*SpaceConstraintList, error)
	GetSpaceConstraint(ctx context.Context, id string, options *metav1.GetOptions) (*SpaceConstraint, error)
	CreateSpaceConstraint(ctx context.Context, id *SpaceConstraint) (*SpaceConstraint, error)
	UpdateSpaceConstraint(ctx context.Context, id *SpaceConstraint) (*SpaceConstraint, error)
	DeleteSpaceConstraint(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSpaceConstraintRegistry(sp builders.StandardStorageProvider) SpaceConstraintRegistry {
	return &storageSpaceConstraint{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSpaceConstraint struct {
	builders.StandardStorageProvider
}

func (s *storageSpaceConstraint) ListSpaceConstraints(ctx context.Context, options *internalversion.ListOptions) (*SpaceConstraintList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceConstraintList), err
}

func (s *storageSpaceConstraint) GetSpaceConstraint(ctx context.Context, id string, options *metav1.GetOptions) (*SpaceConstraint, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceConstraint), nil
}

func (s *storageSpaceConstraint) CreateSpaceConstraint(ctx context.Context, object *SpaceConstraint) (*SpaceConstraint, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceConstraint), nil
}

func (s *storageSpaceConstraint) UpdateSpaceConstraint(ctx context.Context, object *SpaceConstraint) (*SpaceConstraint, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceConstraint), nil
}

func (s *storageSpaceConstraint) DeleteSpaceConstraint(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// SpaceInstance Functions and Structs
//
// +k8s:deepcopy-gen=false
type SpaceInstanceStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SpaceInstanceStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SpaceInstanceList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []SpaceInstance
}

func (SpaceInstance) NewStatus() interface{} {
	return SpaceInstanceStatus{}
}

func (pc *SpaceInstance) GetStatus() interface{} {
	return pc.Status
}

func (pc *SpaceInstance) SetStatus(s interface{}) {
	pc.Status = s.(SpaceInstanceStatus)
}

func (pc *SpaceInstance) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SpaceInstance) SetSpec(s interface{}) {
	pc.Spec = s.(SpaceInstanceSpec)
}

func (pc *SpaceInstance) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SpaceInstance) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SpaceInstance) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SpaceInstance.
// +k8s:deepcopy-gen=false
type SpaceInstanceRegistry interface {
	ListSpaceInstances(ctx context.Context, options *internalversion.ListOptions) (*SpaceInstanceList, error)
	GetSpaceInstance(ctx context.Context, id string, options *metav1.GetOptions) (*SpaceInstance, error)
	CreateSpaceInstance(ctx context.Context, id *SpaceInstance) (*SpaceInstance, error)
	UpdateSpaceInstance(ctx context.Context, id *SpaceInstance) (*SpaceInstance, error)
	DeleteSpaceInstance(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSpaceInstanceRegistry(sp builders.StandardStorageProvider) SpaceInstanceRegistry {
	return &storageSpaceInstance{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSpaceInstance struct {
	builders.StandardStorageProvider
}

func (s *storageSpaceInstance) ListSpaceInstances(ctx context.Context, options *internalversion.ListOptions) (*SpaceInstanceList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceInstanceList), err
}

func (s *storageSpaceInstance) GetSpaceInstance(ctx context.Context, id string, options *metav1.GetOptions) (*SpaceInstance, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceInstance), nil
}

func (s *storageSpaceInstance) CreateSpaceInstance(ctx context.Context, object *SpaceInstance) (*SpaceInstance, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceInstance), nil
}

func (s *storageSpaceInstance) UpdateSpaceInstance(ctx context.Context, object *SpaceInstance) (*SpaceInstance, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceInstance), nil
}

func (s *storageSpaceInstance) DeleteSpaceInstance(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// SpaceTemplate Functions and Structs
//
// +k8s:deepcopy-gen=false
type SpaceTemplateStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SpaceTemplateStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SpaceTemplateList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []SpaceTemplate
}

func (SpaceTemplate) NewStatus() interface{} {
	return SpaceTemplateStatus{}
}

func (pc *SpaceTemplate) GetStatus() interface{} {
	return pc.Status
}

func (pc *SpaceTemplate) SetStatus(s interface{}) {
	pc.Status = s.(SpaceTemplateStatus)
}

func (pc *SpaceTemplate) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SpaceTemplate) SetSpec(s interface{}) {
	pc.Spec = s.(SpaceTemplateSpec)
}

func (pc *SpaceTemplate) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SpaceTemplate) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SpaceTemplate) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SpaceTemplate.
// +k8s:deepcopy-gen=false
type SpaceTemplateRegistry interface {
	ListSpaceTemplates(ctx context.Context, options *internalversion.ListOptions) (*SpaceTemplateList, error)
	GetSpaceTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*SpaceTemplate, error)
	CreateSpaceTemplate(ctx context.Context, id *SpaceTemplate) (*SpaceTemplate, error)
	UpdateSpaceTemplate(ctx context.Context, id *SpaceTemplate) (*SpaceTemplate, error)
	DeleteSpaceTemplate(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSpaceTemplateRegistry(sp builders.StandardStorageProvider) SpaceTemplateRegistry {
	return &storageSpaceTemplate{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSpaceTemplate struct {
	builders.StandardStorageProvider
}

func (s *storageSpaceTemplate) ListSpaceTemplates(ctx context.Context, options *internalversion.ListOptions) (*SpaceTemplateList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceTemplateList), err
}

func (s *storageSpaceTemplate) GetSpaceTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*SpaceTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceTemplate), nil
}

func (s *storageSpaceTemplate) CreateSpaceTemplate(ctx context.Context, object *SpaceTemplate) (*SpaceTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceTemplate), nil
}

func (s *storageSpaceTemplate) UpdateSpaceTemplate(ctx context.Context, object *SpaceTemplate) (*SpaceTemplate, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceTemplate), nil
}

func (s *storageSpaceTemplate) DeleteSpaceTemplate(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// SubjectAccessReview Functions and Structs
//
// +k8s:deepcopy-gen=false
type SubjectAccessReviewStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SubjectAccessReviewStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SubjectAccessReviewList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []SubjectAccessReview
}

func (SubjectAccessReview) NewStatus() interface{} {
	return SubjectAccessReviewStatus{}
}

func (pc *SubjectAccessReview) GetStatus() interface{} {
	return pc.Status
}

func (pc *SubjectAccessReview) SetStatus(s interface{}) {
	pc.Status = s.(SubjectAccessReviewStatus)
}

func (pc *SubjectAccessReview) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SubjectAccessReview) SetSpec(s interface{}) {
	pc.Spec = s.(SubjectAccessReviewSpec)
}

func (pc *SubjectAccessReview) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SubjectAccessReview) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SubjectAccessReview) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SubjectAccessReview.
// +k8s:deepcopy-gen=false
type SubjectAccessReviewRegistry interface {
	ListSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SubjectAccessReviewList, error)
	GetSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SubjectAccessReview, error)
	CreateSubjectAccessReview(ctx context.Context, id *SubjectAccessReview) (*SubjectAccessReview, error)
	UpdateSubjectAccessReview(ctx context.Context, id *SubjectAccessReview) (*SubjectAccessReview, error)
	DeleteSubjectAccessReview(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSubjectAccessReviewRegistry(sp builders.StandardStorageProvider) SubjectAccessReviewRegistry {
	return &storageSubjectAccessReview{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSubjectAccessReview struct {
	builders.StandardStorageProvider
}

func (s *storageSubjectAccessReview) ListSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SubjectAccessReviewList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReviewList), err
}

func (s *storageSubjectAccessReview) GetSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReview), nil
}

func (s *storageSubjectAccessReview) CreateSubjectAccessReview(ctx context.Context, object *SubjectAccessReview) (*SubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReview), nil
}

func (s *storageSubjectAccessReview) UpdateSubjectAccessReview(ctx context.Context, object *SubjectAccessReview) (*SubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReview), nil
}

func (s *storageSubjectAccessReview) DeleteSubjectAccessReview(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Task Functions and Structs
//
// +k8s:deepcopy-gen=false
type TaskStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type TaskStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TaskList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Task
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TaskLogList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []TaskLog
}

func (Task) NewStatus() interface{} {
	return TaskStatus{}
}

func (pc *Task) GetStatus() interface{} {
	return pc.Status
}

func (pc *Task) SetStatus(s interface{}) {
	pc.Status = s.(TaskStatus)
}

func (pc *Task) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Task) SetSpec(s interface{}) {
	pc.Spec = s.(TaskSpec)
}

func (pc *Task) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Task) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Task) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Task.
// +k8s:deepcopy-gen=false
type TaskRegistry interface {
	ListTasks(ctx context.Context, options *internalversion.ListOptions) (*TaskList, error)
	GetTask(ctx context.Context, id string, options *metav1.GetOptions) (*Task, error)
	CreateTask(ctx context.Context, id *Task) (*Task, error)
	UpdateTask(ctx context.Context, id *Task) (*Task, error)
	DeleteTask(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewTaskRegistry(sp builders.StandardStorageProvider) TaskRegistry {
	return &storageTask{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageTask struct {
	builders.StandardStorageProvider
}

func (s *storageTask) ListTasks(ctx context.Context, options *internalversion.ListOptions) (*TaskList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*TaskList), err
}

func (s *storageTask) GetTask(ctx context.Context, id string, options *metav1.GetOptions) (*Task, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Task), nil
}

func (s *storageTask) CreateTask(ctx context.Context, object *Task) (*Task, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Task), nil
}

func (s *storageTask) UpdateTask(ctx context.Context, object *Task) (*Task, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Task), nil
}

func (s *storageTask) DeleteTask(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Team Functions and Structs
//
// +k8s:deepcopy-gen=false
type TeamStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type TeamStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Team
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamAccessKeysList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []TeamAccessKeys
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamClustersList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []TeamClusters
}

func (Team) NewStatus() interface{} {
	return TeamStatus{}
}

func (pc *Team) GetStatus() interface{} {
	return pc.Status
}

func (pc *Team) SetStatus(s interface{}) {
	pc.Status = s.(TeamStatus)
}

func (pc *Team) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Team) SetSpec(s interface{}) {
	pc.Spec = s.(TeamSpec)
}

func (pc *Team) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Team) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Team) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Team.
// +k8s:deepcopy-gen=false
type TeamRegistry interface {
	ListTeams(ctx context.Context, options *internalversion.ListOptions) (*TeamList, error)
	GetTeam(ctx context.Context, id string, options *metav1.GetOptions) (*Team, error)
	CreateTeam(ctx context.Context, id *Team) (*Team, error)
	UpdateTeam(ctx context.Context, id *Team) (*Team, error)
	DeleteTeam(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewTeamRegistry(sp builders.StandardStorageProvider) TeamRegistry {
	return &storageTeam{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageTeam struct {
	builders.StandardStorageProvider
}

func (s *storageTeam) ListTeams(ctx context.Context, options *internalversion.ListOptions) (*TeamList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*TeamList), err
}

func (s *storageTeam) GetTeam(ctx context.Context, id string, options *metav1.GetOptions) (*Team, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Team), nil
}

func (s *storageTeam) CreateTeam(ctx context.Context, object *Team) (*Team, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Team), nil
}

func (s *storageTeam) UpdateTeam(ctx context.Context, object *Team) (*Team, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Team), nil
}

func (s *storageTeam) DeleteTeam(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// User Functions and Structs
//
// +k8s:deepcopy-gen=false
type UserStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type UserStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []User
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserAccessKeysList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []UserAccessKeys
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserClustersList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []UserClusters
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserPermissionsList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []UserPermissions
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserProfileList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []UserProfile
}

func (User) NewStatus() interface{} {
	return UserStatus{}
}

func (pc *User) GetStatus() interface{} {
	return pc.Status
}

func (pc *User) SetStatus(s interface{}) {
	pc.Status = s.(UserStatus)
}

func (pc *User) GetSpec() interface{} {
	return pc.Spec
}

func (pc *User) SetSpec(s interface{}) {
	pc.Spec = s.(UserSpec)
}

func (pc *User) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *User) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc User) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store User.
// +k8s:deepcopy-gen=false
type UserRegistry interface {
	ListUsers(ctx context.Context, options *internalversion.ListOptions) (*UserList, error)
	GetUser(ctx context.Context, id string, options *metav1.GetOptions) (*User, error)
	CreateUser(ctx context.Context, id *User) (*User, error)
	UpdateUser(ctx context.Context, id *User) (*User, error)
	DeleteUser(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewUserRegistry(sp builders.StandardStorageProvider) UserRegistry {
	return &storageUser{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageUser struct {
	builders.StandardStorageProvider
}

func (s *storageUser) ListUsers(ctx context.Context, options *internalversion.ListOptions) (*UserList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*UserList), err
}

func (s *storageUser) GetUser(ctx context.Context, id string, options *metav1.GetOptions) (*User, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*User), nil
}

func (s *storageUser) CreateUser(ctx context.Context, object *User) (*User, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*User), nil
}

func (s *storageUser) UpdateUser(ctx context.Context, object *User) (*User, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*User), nil
}

func (s *storageUser) DeleteUser(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// VirtualClusterInstance Functions and Structs
//
// +k8s:deepcopy-gen=false
type VirtualClusterInstanceStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type VirtualClusterInstanceStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterInstanceList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []VirtualClusterInstance
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterInstanceKubeConfigList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []VirtualClusterInstanceKubeConfig
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterInstanceLogList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []VirtualClusterInstanceLog
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterInstanceWorkloadKubeConfigList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []VirtualClusterInstanceWorkloadKubeConfig
}

func (VirtualClusterInstance) NewStatus() interface{} {
	return VirtualClusterInstanceStatus{}
}

func (pc *VirtualClusterInstance) GetStatus() interface{} {
	return pc.Status
}

func (pc *VirtualClusterInstance) SetStatus(s interface{}) {
	pc.Status = s.(VirtualClusterInstanceStatus)
}

func (pc *VirtualClusterInstance) GetSpec() interface{} {
	return pc.Spec
}

func (pc *VirtualClusterInstance) SetSpec(s interface{}) {
	pc.Spec = s.(VirtualClusterInstanceSpec)
}

func (pc *VirtualClusterInstance) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *VirtualClusterInstance) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc VirtualClusterInstance) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store VirtualClusterInstance.
// +k8s:deepcopy-gen=false
type VirtualClusterInstanceRegistry interface {
	ListVirtualClusterInstances(ctx context.Context, options *internalversion.ListOptions) (*VirtualClusterInstanceList, error)
	GetVirtualClusterInstance(ctx context.Context, id string, options *metav1.GetOptions) (*VirtualClusterInstance, error)
	CreateVirtualClusterInstance(ctx context.Context, id *VirtualClusterInstance) (*VirtualClusterInstance, error)
	UpdateVirtualClusterInstance(ctx context.Context, id *VirtualClusterInstance) (*VirtualClusterInstance, error)
	DeleteVirtualClusterInstance(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewVirtualClusterInstanceRegistry(sp builders.StandardStorageProvider) VirtualClusterInstanceRegistry {
	return &storageVirtualClusterInstance{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageVirtualClusterInstance struct {
	builders.StandardStorageProvider
}

func (s *storageVirtualClusterInstance) ListVirtualClusterInstances(ctx context.Context, options *internalversion.ListOptions) (*VirtualClusterInstanceList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterInstanceList), err
}

func (s *storageVirtualClusterInstance) GetVirtualClusterInstance(ctx context.Context, id string, options *metav1.GetOptions) (*VirtualClusterInstance, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterInstance), nil
}

func (s *storageVirtualClusterInstance) CreateVirtualClusterInstance(ctx context.Context, object *VirtualClusterInstance) (*VirtualClusterInstance, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterInstance), nil
}

func (s *storageVirtualClusterInstance) UpdateVirtualClusterInstance(ctx context.Context, object *VirtualClusterInstance) (*VirtualClusterInstance, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterInstance), nil
}

func (s *storageVirtualClusterInstance) DeleteVirtualClusterInstance(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// VirtualClusterTemplate Functions and Structs
//
// +k8s:deepcopy-gen=false
type VirtualClusterTemplateStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type VirtualClusterTemplateStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterTemplateList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []VirtualClusterTemplate
}

func (VirtualClusterTemplate) NewStatus() interface{} {
	return VirtualClusterTemplateStatus{}
}

func (pc *VirtualClusterTemplate) GetStatus() interface{} {
	return pc.Status
}

func (pc *VirtualClusterTemplate) SetStatus(s interface{}) {
	pc.Status = s.(VirtualClusterTemplateStatus)
}

func (pc *VirtualClusterTemplate) GetSpec() interface{} {
	return pc.Spec
}

func (pc *VirtualClusterTemplate) SetSpec(s interface{}) {
	pc.Spec = s.(VirtualClusterTemplateSpec)
}

func (pc *VirtualClusterTemplate) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *VirtualClusterTemplate) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc VirtualClusterTemplate) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store VirtualClusterTemplate.
// +k8s:deepcopy-gen=false
type VirtualClusterTemplateRegistry interface {
	ListVirtualClusterTemplates(ctx context.Context, options *internalversion.ListOptions) (*VirtualClusterTemplateList, error)
	GetVirtualClusterTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*VirtualClusterTemplate, error)
	CreateVirtualClusterTemplate(ctx context.Context, id *VirtualClusterTemplate) (*VirtualClusterTemplate, error)
	UpdateVirtualClusterTemplate(ctx context.Context, id *VirtualClusterTemplate) (*VirtualClusterTemplate, error)
	DeleteVirtualClusterTemplate(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewVirtualClusterTemplateRegistry(sp builders.StandardStorageProvider) VirtualClusterTemplateRegistry {
	return &storageVirtualClusterTemplate{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageVirtualClusterTemplate struct {
	builders.StandardStorageProvider
}

func (s *storageVirtualClusterTemplate) ListVirtualClusterTemplates(ctx context.Context, options *internalversion.ListOptions) (*VirtualClusterTemplateList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterTemplateList), err
}

func (s *storageVirtualClusterTemplate) GetVirtualClusterTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*VirtualClusterTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterTemplate), nil
}

func (s *storageVirtualClusterTemplate) CreateVirtualClusterTemplate(ctx context.Context, object *VirtualClusterTemplate) (*VirtualClusterTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterTemplate), nil
}

func (s *storageVirtualClusterTemplate) UpdateVirtualClusterTemplate(ctx context.Context, object *VirtualClusterTemplate) (*VirtualClusterTemplate, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterTemplate), nil
}

func (s *storageVirtualClusterTemplate) DeleteVirtualClusterTemplate(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}
